<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tanki Online Icon Viewer</title>
    <style>@import url('https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap'); @import url('https://fonts.googleapis.com/css2?family=M+PLUS+1p&display=swap');</style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        :root {
            --color-primary: #76FF33;      /* 荧光绿 */
            --color-background: #001926;   /* 深海蓝 */
            --color-text: #BFD5FF;         /* 淡蓝 */
            
            --color-surface: #002233;      /* 卡片背景 */
            --color-surface-hover: #003045;
            --color-border: #1a4d66;       
            
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        body {
            background-color: var(--color-background);
            color: var(--color-text);
            font-family: 'Rubik', 'M PLUS 1p', sans-serif;
            margin: 0;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .material-symbols-rounded {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            user-select: none;
            display: inline-block;
            vertical-align: middle;
        }
        
        .icon-filled {
            font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            padding: 0 20px;
            box-sizing: border-box;
            flex: 1; 
        }

        header { text-align: center; margin-bottom: 0px; flex-shrink: 0; }
        h1 { font-weight: 400; color: var(--color-primary); margin: 0; }

        /* Filter Chips */
        .filter-container-wrapper {
            width: 100%;
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(180deg, var(--color-background) 80%, transparent);
            padding-bottom: 10px;
            margin-bottom: 10px;
            min-height: 50px;
            flex-shrink: 0;
        }

        .filter-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 4px 20px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .filter-scroll::-webkit-scrollbar { display: none; }

        .filter-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 16px;
            height: 36px;
            border-radius: 8px;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            color: var(--color-text);
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            flex-shrink: 0;
        }

        .filter-chip.active {
            background-color: var(--color-primary);
            color: var(--color-background);
            border-color: var(--color-primary);
            box-shadow: 0 0 10px rgba(118, 255, 51, 0.3);
        }

        .filter-chip .material-symbols-rounded { font-size: 20px; }
        .chip-count {
            font-size: 0.75rem; opacity: 0.7; background: rgba(0,0,0,0.2);
            padding: 2px 6px; border-radius: 4px;
        }

        /* --- Loading Progress Bar --- */
        .loading-wrapper {
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 46px; 
        }

        .progress-track {
            width: 100%;
            max-width: 400px;
            height: 4px;
            background-color: var(--color-surface);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--color-primary);
            box-shadow: 0 0 10px var(--color-primary);
            transition: width 0.1s linear; 
        }

        .loading-text {
            font-size: 0.75rem;
            color: var(--color-text);
            margin-top: 8px;
            opacity: 0.8;
            font-family: monospace;
        }

        .error-msg {
            color: #ffb4ab;
            font-size: 0.9rem;
            background: rgba(255, 180, 171, 0.1);
            padding: 8px 16px;
            border-radius: 8px;
        }

        /* Grid */
        #resources {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
            width: 100%;
            align-items: start; 
        }

        .resource-item {
            background-color: var(--color-surface);
            border: 1px solid transparent;
            border-radius: var(--radius-lg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: all 0.2s;
            cursor: pointer;
            user-select: none;
        }

        .resource-item:active { transform: scale(0.98); }
        .resource-item:hover { border-color: var(--color-text); }
        
        /* --- 预览区域 --- */
        .preview-area {
            width: 100%;
            height: auto;
            min-height: 120px; 
            background-color: var(--color-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Image */
        .preview-area.type-image {
            height: 180px; 
            padding: 16px;
            box-sizing: border-box;
        }

        .preview-area.type-image img {
            width: auto; height: auto;
            max-width: 100%; max-height: 100%;
            pointer-events: none;
        }

        /* Audio */
        .preview-area.type-audio {
            padding: 16px;
            height: 120px;
            background: radial-gradient(circle at center, #003045 0%, #002233 100%);
            flex-direction: column;
            gap: 15px;
            justify-content: center;
            align-items: center; 
        }
        
        audio {
            width: 90%; 
            height: 32px;
            filter: invert(1) hue-rotate(180deg);
            opacity: 0.9;
            display: block;
        }

        /* Video */
        .preview-area:has(.custom-player) { 
            padding: 0; 
            background-color: var(--color-surface);
            height: auto; 
            min-height: 140px;
        }

        .info-area { padding: 12px; text-align: center; }

        .file-name {
            font-size: 0.85rem; color: var(--color-text);
            word-break: break-all;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* --- Custom Video Player --- */
        .custom-player {
            width: 100%; height: auto; display: flex; flex-direction: column; 
            background: transparent;
        }
        
        .custom-player video {
            width: 100%; height: auto; display: block; 
            background: transparent;
            object-fit: contain; 
            pointer-events: auto;
        }

        .player-controls {
            position: relative; z-index: 5; 
            background: var(--color-surface-hover); 
            border-top: 1px solid rgba(191, 213, 255, 0.1); 
            padding: 0 10px; 
            display: flex; align-items: center; gap: 8px; 
            height: 40px; flex-shrink: 0;
        }

        .play-btn {
            background: none; border: none; padding: 0; cursor: pointer;
            width: 24px; height: 24px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            color: var(--color-primary);
        }
        .play-btn .material-symbols-rounded { font-size: 24px; }

        .progress-bar-container {
            flex-grow: 1; height: 20px; display: flex; align-items: center;
            cursor: pointer; position: relative;
        }
        .progress-bar {
            width: 100%; height: 4px; background: rgba(191, 213, 255, 0.2);
            border-radius: 2px; position: relative; pointer-events: none;
        }
        .progress-fill {
            height: 100%; background-color: var(--color-primary);
            width: 0%; border-radius: 2px; position: absolute; top: 0; left: 0;
        }
        .progress-thumb {
            width: 12px; height: 12px; background: var(--color-primary); border-radius: 50%;
            position: absolute; top: 50%; right: -6px;
            transform: translateY(-50%) scale(0); transition: transform 0.1s;
            box-shadow: 0 0 8px rgba(118, 255, 51, 0.5);
        }
        .progress-bar-container:hover .progress-thumb { transform: translateY(-50%) scale(1); }
        .time-display { font-size: 0.7rem; color: var(--color-text); width: 35px; text-align: right; font-family: monospace; }

        /* Fullscreen Image Viewer */
        .dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 25, 38, 0.95); display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.2s ease-out; z-index: 1000; backdrop-filter: blur(5px);
        }
        .dialog-overlay.active { opacity: 1; pointer-events: auto; }

        #imagePreviewContainer {
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; position: relative;
        }
        
        #fullScreenImage {
            max-width: 95vw; max-height: 90vh; object-fit: contain;
            border-radius: 0; /* No rounded corners */
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            pointer-events: auto;
            transition: opacity 0.1s;
        }

        #fullScreenImage[src=""],
        #fullScreenImage:not([src]) {
            opacity: 0;
            visibility: hidden;
            display: none;
        }

        .close-fullscreen-btn {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.5); border: none;
            color: var(--color-primary); width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: 0.2s; z-index: 10;
        }
        .close-fullscreen-btn:hover { background: rgba(255,255,255,0.1); }

        footer { text-align: center; color: var(--color-text); font-size: 0.8rem; margin-top: 40px; opacity: 0.6; flex-shrink: 0; }
    </style>
</head>
<body>

    <header>
        <h1 id="pageTitle">Tanki Online Icon Viewer</h1>
    </header>

    <div class="filter-container-wrapper" id="topControlArea">
        <!-- Progress Bar or Filter Chips will be rendered here -->
    </div>

    <div class="container">
        <div id="resources"></div>
    </div>

    <footer>
        <span id="sourceInfo"></span>
    </footer>

    <!-- Full Screen Image Viewer -->
    <div class="dialog-overlay" id="imageViewer">
        <div id="imagePreviewContainer">
            <button class="close-fullscreen-btn" onclick="closeImageViewer()">×</button>
            <img id="fullScreenImage" src="" alt="Preview">
        </div>
    </div>

    <script>
        const ICONS = {
            play: 'play_arrow', pause: 'pause', c_gif: 'gif', c_video: 'video_file',
            c_svg: 'gesture', c_img: 'image', c_aud: 'audio_file', c_file: 'draft'
        };

        function getIcon(name, isFilled = false) {
            return `<span class="material-symbols-rounded ${isFilled ? 'icon-filled' : ''}">${name}</span>`;
        }

        // 界面语言依然由浏览器决定
        const isBrowserChinese = navigator.language.toLowerCase().startsWith('zh');
        
        let CONFIG = {
            // baseUrl 将由 IP 检测决定
            baseUrl: '', 
            labels: {
                title: isBrowserChinese ? '3D坦克网页图标浏览' : 'Tanki Online Icon Viewer',
                step1: isBrowserChinese ? '加载中... (1/4)' : 'Loading... (1/4)',
                step2: isBrowserChinese ? '加载中... (2/4)' : 'Loading... (2/4)',
                step3: isBrowserChinese ? '加载中... (3/4)' : 'Loading... (3/4)',
                step4: isBrowserChinese ? '加载中... (4/4)' : 'Loading... (4/4)',
                done: isBrowserChinese ? '加载完成' : 'Done', 
                error: isBrowserChinese ? '加载失败' : 'Failed to load',
                source: isBrowserChinese ? '数据源: ' : 'Data Source: '
            }
        };

        document.getElementById('pageTitle').textContent = CONFIG.labels.title;

        let resources = {};

        // 渲染进度条
        function renderProgressUI() {
            const container = document.getElementById('topControlArea');
            container.innerHTML = `
                <div class="loading-wrapper">
                    <div class="progress-track">
                        <div class="progress-fill" id="progressBarFill"></div>
                    </div>
                    <div class="loading-text" id="progressText">${CONFIG.labels.step1}</div>
                </div>
            `;
        }

        function updateProgress(percent, text) {
            const fill = document.getElementById('progressBarFill');
            const txt = document.getElementById('progressText');
            if(fill) fill.style.width = percent + '%';
            if(txt && text) txt.textContent = text;
        }

        function showErrorMessage(msg) {
            const container = document.getElementById('topControlArea');
            container.innerHTML = `<div class="loading-wrapper"><div class="error-msg">${msg}</div></div>`;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 检测是否在中国大陆 (直连 Cloudflare)
        async function checkIsChina() {
            try {
                // 必须直连，不能走代理，否则检测到的是代理服务器的 IP
                const response = await fetch('https://www.cloudflare.com/cdn-cgi/trace', {
                    cache: 'no-cache'
                });
                if (!response.ok) return false; 
                const text = await response.text();
                
                // 解析 loc=CN
                const lines = text.split('\n');
                for (const line of lines) {
                    if (line.startsWith('loc=')) {
                        const loc = line.split('=')[1];
                        console.log("Detected Region:", loc);
                        return loc === 'CN';
                    }
                }
            } catch (e) {
                console.warn("Cloudflare trace failed, defaulting to Global logic.", e);
            }
            return false;
        }

        async function downloadWithProgress(url, onProgress) {
            const proxyBase = 'https://api.codetabs.com/v1/proxy?quest=';
            const target = proxyBase + encodeURIComponent(url);
            
            const response = await fetch(target);
            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);

            const contentLength = response.headers.get('content-length');
            const total = contentLength ? parseInt(contentLength, 10) : 0;
            let loaded = 0;

            const reader = response.body.getReader();
            const chunks = [];

            while(true) {
                const {done, value} = await reader.read();
                if (done) break;
                
                chunks.push(value);
                loaded += value.length;
                
                if (onProgress) {
                    onProgress(loaded, total);
                }
            }

            let position = 0;
            const allChunks = new Uint8Array(loaded);
            for(const chunk of chunks) {
                allChunks.set(chunk, position);
                position += chunk.length;
            }
            
            return new TextDecoder("utf-8").decode(allChunks);
        }

        async function fetchSimple(url) {
            const proxyBase = 'https://api.codetabs.com/v1/proxy?quest=';
            const target = proxyBase + encodeURIComponent(url);
            const response = await fetch(target);
            if (!response.ok) throw new Error(`Status ${response.status}`);
            return await response.text();
        }

        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        async function init() {
            renderProgressUI();

            try {
                // Step 1: 包含 IP 检测和获取 HTML
                // 不显示单独的检测提示，直接从 Step 1 开始
                updateProgress(5, CONFIG.labels.step1);
                
                // 静默执行 IP 检测
                const isChina = await checkIsChina();
                
                // 根据 IP 设定数据源
                if (isChina) {
                    CONFIG.baseUrl = 'https://3dtank.com/play/';
                } else {
                    CONFIG.baseUrl = 'https://tankionline.com/play/';
                }
                
                // 更新页脚显示数据源
                document.getElementById('sourceInfo').textContent = CONFIG.labels.source + new URL(CONFIG.baseUrl).hostname;

                // 继续 Step 1: 获取 HTML
                updateProgress(10, CONFIG.labels.step1); 
                const html = await fetchSimple(CONFIG.baseUrl);
                updateProgress(25, CONFIG.labels.step2);

                // Step 2: 提取 JS 链接 (50%)
                const scriptRegex = /src="(\/play\/static\/js\/main\.[a-z0-9]+\.js)"/;
                const match = html.match(scriptRegex);

                if (!match || !match[1]) throw new Error("Version check failed");

                const origin = new URL(CONFIG.baseUrl).origin;
                const fullScriptUrl = origin + match[1];

                // Step 3: 下载 JS (50% -> 85%)
                const jsContent = await downloadWithProgress(fullScriptUrl, (loaded, total) => {
                    const loadedStr = formatBytes(loaded);
                    let progressText = `${CONFIG.labels.step3} - ${loadedStr}`;
                    let percent = 25; 

                    if (total > 0) {
                        const totalStr = formatBytes(total);
                        progressText += ` / ${totalStr}`;
                        const downloadRatio = loaded / total;
                        percent = 25 + (downloadRatio * 60); 
                    } else {
                        percent = 55;
                    }
                    
                    updateProgress(percent, progressText);
                });
                
                // Step 4: 准备开始解析 (100%)
                updateProgress(85, CONFIG.labels.step4); 
                await delay(100); 

                const assetRegex = /\.p\+"(.*?)"/g;
                let assetMatch;
                let foundCount = 0;

                while ((assetMatch = assetRegex.exec(jsContent)) !== null) {
                    let path = assetMatch[1].replace('SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED', '');
                    if (!path) continue;
                    
                    const fullUrl = CONFIG.baseUrl + path;
                    const ext = path.split('.').pop().toLowerCase();
                    
                    if (!resources[ext]) resources[ext] = [];
                    if (!resources[ext].includes(fullUrl)) {
                        resources[ext].push(fullUrl);
                        foundCount++;
                    }
                }

                if (foundCount === 0) throw new Error("No content found");

                updateProgress(100, CONFIG.labels.done);
                await delay(300); 

                renderFilters();

            } catch (e) {
                console.error(e);
                showErrorMessage(`${CONFIG.labels.error}: ${e.message}`);
            }
        }

        function renderFilters() {
            const container = document.getElementById('topControlArea');
            container.innerHTML = '<div class="filter-scroll" id="filterScroll"></div>';
            const scrollArea = document.getElementById('filterScroll');

            const typeWeight = {
                'svg': 10, 'png': 10, 'jpg': 10, 'jpeg': 10, 'webp': 10, 'gif': 10,
                'webm': 19, 'mp4': 20, 'mp3': 30, 'wav': 30, 'ogg': 30
            };

            const ignore = ['js', 'css', 'map', 'json', 'txt', 'xml', '3ds'];
            let extensions = Object.keys(resources).filter(k => !ignore.includes(k));

            extensions.sort((a, b) => {
                const wA = typeWeight[a] || 50; 
                const wB = typeWeight[b] || 50;
                if (wA !== wB) return wA - wB;
                const countA = resources[a].length;
                const countB = resources[b].length;
                if (countA !== countB) return countB - countA;
                return a.localeCompare(b);
            });
            
            extensions.forEach((ext, index) => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                const count = resources[ext].length;
                
                let iconName = ICONS.c_file;
                if (ext === 'svg') iconName = ICONS.c_svg;
                else if (['png','jpg','jpeg','webp'].includes(ext)) iconName = ICONS.c_img;
                else if (ext === 'gif') iconName = ICONS.c_gif;
                else if (ext === 'mp4' || ext === 'webm') iconName = ICONS.c_video; 
                else if (['mp3','wav','ogg'].includes(ext)) iconName = ICONS.c_aud;

                chip.innerHTML = `${getIcon(iconName)} <span>${ext.toUpperCase()}</span> <span class="chip-count">${count}</span>`;
                
                chip.onclick = () => {
                    document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    renderResources(ext);
                };

                if (index === 0) {
                    chip.classList.add('active');
                    renderResources(ext);
                }
                
                scrollArea.appendChild(chip);
            });
        }

        function formatName(url) {
            let name = url.split('/').pop();
            const parts = name.split('.');
            if (parts.length > 2) parts.splice(parts.length - 2, 1);
            name = parts.slice(0, -1).join('.');
            return name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' ');
        }

        function renderResources(type) {
            const container = document.getElementById('resources');
            container.innerHTML = '';

            resources[type].forEach(url => {
                const item = document.createElement('div');
                item.className = 'resource-item';
                const fName = formatName(url);

                const preview = document.createElement('div');
                preview.className = 'preview-area';

                if (['png', 'jpg', 'jpeg', 'webp', 'gif', 'svg'].includes(type)) {
                    preview.classList.add('type-image');
                    const img = document.createElement('img');
                    img.src = url;
                    img.loading = "lazy";
                    preview.appendChild(img);
                    
                    item.onclick = () => {
                        const fullScreenImg = document.getElementById('fullScreenImage');
                        fullScreenImg.style.display = 'block'; 
                        fullScreenImg.style.visibility = 'visible';
                        fullScreenImg.style.opacity = '1';
                        fullScreenImg.src = url;
                        document.getElementById('imageViewer').classList.add('active');
                    };
                } 
                else if (['mp3', 'wav', 'ogg'].includes(type)) {
                    preview.classList.add('type-audio');
                    const iconDiv = document.createElement('div');
                    iconDiv.innerHTML = getIcon(ICONS.c_aud);
                    iconDiv.style.color = 'var(--color-primary)';
                    iconDiv.style.fontSize = '32px';
                    preview.appendChild(iconDiv);

                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = url;
                    audio.preload = "none";
                    preview.appendChild(audio);
                    item.style.cursor = "default";
                } 
                else if (['mp4', 'webm'].includes(type)) {
                    createCustomVideo(preview, url);
                } 
                else {
                    preview.innerHTML = getIcon(ICONS.c_file);
                    item.onclick = () => window.open(url, '_blank');
                }

                const info = document.createElement('div');
                info.className = 'info-area';
                const txt = document.createElement('div');
                txt.className = 'file-name';
                txt.textContent = fName;
                info.appendChild(txt);

                item.appendChild(preview);
                item.appendChild(info);
                container.appendChild(item);
            });
        }

        function createCustomVideo(container, url) {
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-player';
            wrapper.innerHTML = `
                <video src="${url}" playsinline preload="metadata"></video>
                <div class="player-controls">
                    <button class="play-btn">${getIcon(ICONS.play, true)}</button>
                    <div class="progress-bar-container"><div class="progress-bar"><div class="progress-fill"><div class="progress-thumb"></div></div></div></div>
                    <div class="time-display">00:00</div>
                </div>`;
            container.appendChild(wrapper);
            bindMediaEvents(wrapper);
        }

        function bindMediaEvents(wrapper) {
            const video = wrapper.querySelector('video');
            if(!video) return; 

            const btn = wrapper.querySelector('.play-btn');
            const barContainer = wrapper.querySelector('.progress-bar-container');
            const fill = wrapper.querySelector('.progress-fill');
            const timeDisplay = wrapper.querySelector('.time-display');

            const togglePlay = () => {
                if (video.paused) {
                    document.querySelectorAll('video').forEach(m => { if(m !== video) m.pause(); });
                    video.play();
                } else { video.pause(); }
            };

            btn.onclick = (e) => { e.stopPropagation(); togglePlay(); };
            video.onclick = (e) => { togglePlay(); };

            video.onplay = () => btn.innerHTML = getIcon(ICONS.pause, true);
            video.onpause = () => btn.innerHTML = getIcon(ICONS.play, true);
            video.onended = () => { btn.innerHTML = getIcon(ICONS.play, true); fill.style.width = '0%'; };

            video.ontimeupdate = () => {
                if(!video.duration) return;
                fill.style.width = ((video.currentTime / video.duration) * 100) + '%';
                timeDisplay.textContent = formatTime(video.currentTime);
            };

            const seek = (e) => {
                if(!video.duration) return;
                const rect = barContainer.getBoundingClientRect();
                let pos = (e.clientX - rect.left) / rect.width;
                video.currentTime = Math.max(0, Math.min(1, pos)) * video.duration;
            };

            barContainer.onclick = (e) => { e.stopPropagation(); seek(e); };
            
            let isDragging = false;
            const startDrag = () => isDragging = true;
            const doDrag = (e) => {
                if(isDragging && video.duration) {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const rect = barContainer.getBoundingClientRect();
                    let pos = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                    fill.style.width = (pos * 100) + '%';
                }
            };
            const endDrag = (e) => {
                if(isDragging && video.duration) {
                    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                    const rect = barContainer.getBoundingClientRect();
                    let pos = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                    video.currentTime = pos * video.duration;
                    isDragging = false;
                }
            };

            barContainer.addEventListener('mousedown', startDrag);
            barContainer.addEventListener('touchstart', startDrag);
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            
            wrapper.querySelector('.player-controls').onclick = (e) => e.stopPropagation();
        }

        function formatTime(s) {
            if(!s) return "00:00";
            return `${Math.floor(s/60).toString().padStart(2,'0')}:${Math.floor(s%60).toString().padStart(2,'0')}`;
        }

        function closeImageViewer() {
            const viewer = document.getElementById('imageViewer');
            viewer.classList.remove('active'); 
            setTimeout(() => {
                const img = document.getElementById('fullScreenImage');
                if (!viewer.classList.contains('active')) img.src = "";
            }, 250);
        }

        document.getElementById('imageViewer').addEventListener('click', (e) => { 
            if(e.target === document.getElementById('imageViewer') || e.target === document.getElementById('imagePreviewContainer')) {
                closeImageViewer(); 
            }
        });

        init();
    </script>
</body>
</html>
