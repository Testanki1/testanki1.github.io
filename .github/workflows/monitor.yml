name: 3Då¦å…‹æµ‹è¯•æœåŠ¡å™¨ç›‘æµ‹å™¨

on:
  schedule:
    - cron: '0 */5 * * *'
  workflow_dispatch:

jobs:
  continuous-monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm i playwright nodemailer p-limit@3
          npx playwright install --with-deps chromium

      - name: Run Persistent Monitor
        env:
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
        run: |
          cat << 'EOF' > monitor.js
          const { chromium } = require('playwright');
          const fs = require('fs');
          const https = require('https');
          const crypto = require('crypto');
          const { execSync } = require('child_process');
          const nodemailer = require('nodemailer');
          const pLimit = require('p-limit');

          // --- é…ç½® ---
          const STATE_FILE = 'server_status.json';
          const CHECK_INTERVAL = 3 * 60 * 1000; // 3åˆ†é’Ÿ
          const MAX_RUNTIME = 5.8 * 60 * 60 * 1000; // 5.8å°æ—¶
          const START_TIME = Date.now();
          const BROWSER_CONCURRENCY = 3; 
          const CONFIRMATION_THRESHOLD = 2; // éœ€è¦è¿ç»­2æ¬¡ç›¸åŒæ‰ç¡®è®¤

          // å¾…ç¡®è®¤çŠ¶æ€ç®¡ç†
          let pendingChanges = {};

          const transporter = nodemailer.createTransport({
            host: "smtp.qq.com",
            port: 465,
            secure: true,
            auth: {
              user: process.env.MAIL_USERNAME,
              pass: process.env.MAIL_PASSWORD
            }
          });

          function getTime() {
            return new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
          }

          // ã€ä¿®å¤1ã€‘å…è®¸é‡å®šå‘çŠ¶æ€ç ï¼Œå¢å¼ºå­˜æ´»åˆ¤æ–­
          function checkCurl(url) {
            return new Promise((resolve) => {
              const req = https.get(url, { 
                rejectUnauthorized: false, 
                timeout: 15000,
                headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
              }, (res) => {
                const { statusCode } = res;
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  // 2xx å’Œ 3xx éƒ½ç®—å­˜æ´»
                  const isAlive = statusCode >= 200 && statusCode < 400;
                  const hash = isAlive ? crypto.createHash('sha256').update(data).digest('hex') : '';
                  resolve({ url, statusCode, hash, isAlive, dataLength: data.length });
                });
              });
              
              req.on('error', (err) => {
                resolve({ url, statusCode: 0, hash: '', isAlive: false, error: err.message });
              });
              
              req.on('timeout', () => {
                req.destroy();
                resolve({ url, statusCode: 0, hash: '', isAlive: false, error: 'Timeout' });
              });
            });
          }

          // ã€ä¿®å¤2ã€‘å¢å¼ºçš„æµè§ˆå™¨æ£€æµ‹ï¼Œå¤„ç†å¯¼èˆªå†²çª
          async function checkBrowserPage(browser, url) {
            let page = null;
            let context = null;
            try {
              context = await browser.newContext({
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                viewport: { width: 1280, height: 720 },
                ignoreHTTPSErrors: true
              });
              
              const targetUrl = url.includes('?') ? url + '&skipEntranceAnyKey' : url + '?skipEntranceAnyKey';
              page = await context.newPage();
              
              // ç¼©çŸ­ç­‰å¾…æ—¶é—´ï¼Œé¿å…æŒ‚æ­»
              const response = await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: 30000 }).catch(e => null);
              
              // æ£€æŸ¥ HTTP çŠ¶æ€ (å¦‚æœæœ‰å“åº”)
              if (response && response.status() >= 400) {
                return { url, status: 'Offline', httpStatus: response.status() };
              }

              // ç­‰å¾…é¡µé¢ç¨³å®š (å¦‚æœè¿™é‡ŒæŠ¥é”™ navigatingï¼Œè¯´æ˜é¡µé¢åœ¨åŠ¨ï¼Œå…¶å®æ˜¯æ´»çš„)
              try {
                await page.waitForLoadState('networkidle', { timeout: 10000 });
              } catch (e) {
                // å¿½ç•¥ networkidle è¶…æ—¶ï¼Œåªè¦ä¸æ˜¯è¿æ¥å¤±è´¥
              }
              
              await page.waitForTimeout(3000);
              
              // è·å–å†…å®¹æ—¶å¢åŠ å®¹é”™
              let content = '';
              try {
                content = await page.content();
              } catch (e) {
                if (e.message.includes('navigating') || e.message.includes('Execution context')) {
                  // ã€å…³é”®ä¿®å¤ã€‘å¦‚æœé¡µé¢æ­£åœ¨è·³è½¬æˆ–åˆ·æ–°ï¼Œè¯´æ˜æœåŠ¡å™¨å“åº”äº†è„šæœ¬ï¼Œåˆ¤å®šä¸º Open
                  console.log(`[${getTime()}] âš ï¸ é¡µé¢æ­£åœ¨è·³è½¬ä¸­ (${url})ï¼Œåˆ¤å®šä¸º Open`);
                  return { url, status: 'Open', note: 'Navigating' };
                }
                throw e;
              }

              // å…³é”®è¯æ£€æµ‹
              const lowerHtml = content.toLowerCase();
              const hasInvitation = lowerHtml.includes('invitation') || 
                                    lowerHtml.includes('é‚€è¯·') || 
                                    lowerHtml.includes('invite code') ||
                                    /class="[^"]*invitation/.test(lowerHtml);
              
              return { 
                url, 
                status: hasInvitation ? 'Closed' : 'Open',
                httpStatus: response ? response.status() : 200
              };
              
            } catch (e) {
              // åŒºåˆ†ç½‘ç»œé”™è¯¯å’Œå…¶ä»–é”™è¯¯
              const isNetError = e.message.includes('ERR_CONNECTION') || e.message.includes('Timeout');
              console.log(`[${getTime()}] æµè§ˆå™¨å¼‚å¸¸ ${url}: ${e.message.slice(0, 100)}`);
              return { url, status: 'Offline', error: e.message, isNetError };
            } finally {
              if (context) await context.close().catch(() => {});
            }
          }

          function commitAndPush() {
            try {
              execSync('git pull --rebase origin main || git pull --rebase origin master || true', { stdio: 'pipe' });
              execSync('git config --global user.name "github-actions[bot]"');
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git add ${STATE_FILE}`);
              
              const status = execSync('git status --porcelain').toString();
              if (status) {
                execSync('git commit -m "chore: æ›´æ–°æœåŠ¡å™¨çŠ¶æ€æ–‡ä»¶"');
                execSync('git push');
                console.log(`[${getTime()}] Git çŠ¶æ€å·²æ›´æ–°å¹¶æ¨é€ã€‚`);
                return true;
              }
              return false;
            } catch (e) {
              console.error(`[${getTime()}] Git æäº¤å¤±è´¥:`, e.message);
              return false;
            }
          }

          async function sendEmail(body) {
            try {
              await transporter.sendMail({
                from: `"3Då¦å…‹æµ‹è¯•æœç›‘æµ‹å™¨" <${process.env.MAIL_USERNAME}>`,
                to: process.env.MAIL_TO,
                subject: "3Då¦å…‹æµ‹è¯•æœåŠ¡å™¨çŠ¶æ€æ›´æ–°",
                html: `ä½ å¥½ï¼Œ<br><br>${body}<br><br>æ­¤é‚®ä»¶ç”± GitHub Actions è‡ªåŠ¨ç›‘æµ‹å‘é€ã€‚`
              });
              console.log(`[${getTime()}] é‚®ä»¶å·²å‘é€ã€‚`);
            } catch (error) {
              console.error(`[${getTime()}] é‚®ä»¶å‘é€å¤±è´¥:`, error);
            }
          }

          function isStateEqual(a, b) {
            if (!a || !b) return false;
            return a.status === b.status && a.hash === b.hash;
          }

          async function main() {
            const loopStart = Date.now();
            console.log(`\n[${getTime()}] ========== ç›‘æµ‹å¾ªç¯å¼€å§‹ ==========`);

            // URL åˆ—è¡¨
            const urls = [];
            for (let i = 1; i <= 10; i++) {
              urls.push(`https://public-deploy${i}.test-eu.tankionline.com/browser-public/index.html`);
            }
            urls.push("https://tankiclassic.com/play/");

            // è¯»å–çŠ¶æ€
            let committedStatusJson = {};
            try {
              if (fs.existsSync(STATE_FILE)) {
                committedStatusJson = JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
              }
            } catch (e) {}

            let finalStatusJson = { ...committedStatusJson };
            let notifications = [];
            let availableServers = [];
            let browser = null;
            const currentResults = {};

            try {
              // Phase 1: Curl å¿«é€Ÿç­›é€‰
              console.log(`[${getTime()}] Phase 1: Curl æ£€æµ‹ ${urls.length} ä¸ª URL...`);
              const curlResults = await Promise.all(urls.map(url => checkCurl(url)));
              
              const candidatesForBrowser = [];

              for (const res of curlResults) {
                const { url, isAlive, hash } = res;
                if (isAlive) {
                  candidatesForBrowser.push({ url, hash });
                } else {
                  const oldEntry = committedStatusJson[url] || {};
                  currentResults[url] = { status: "Offline", hash: oldEntry.hash || hash };
                }
              }

              // Phase 2: æµè§ˆå™¨æ·±åº¦æ£€æµ‹
              if (candidatesForBrowser.length > 0) {
                console.log(`[${getTime()}] Phase 2: æµè§ˆå™¨æ£€æµ‹ ${candidatesForBrowser.length} ä¸ªå­˜æ´»ç›®æ ‡...`);
                
                browser = await chromium.launch({ 
                  headless: true,
                  args: ['--no-sandbox', '--disable-setuid-sandbox']
                });
                
                const limit = pLimit(BROWSER_CONCURRENCY);
                const browserPromises = candidatesForBrowser.map(candidate => 
                  limit(async () => {
                    const res = await checkBrowserPage(browser, candidate.url);
                    
                    // ã€ä¿®å¤3ã€‘æ··åˆåˆ¤æ–­é€»è¾‘ï¼šå¦‚æœæµè§ˆå™¨æŒ‚äº†ä½† Curl æ˜¯é€šçš„
                    if (res.status === 'Offline' && !res.isNetError) {
                      console.log(`[${getTime()}] ${candidate.url} æµè§ˆå™¨æ£€æµ‹å¤±è´¥ä½†ç½‘ç»œé€šç•…ï¼Œå¼ºåˆ¶åˆ¤å®šä¸º Open`);
                      return { ...res, status: 'Open' }; 
                    }
                    return res;
                  }).then(res => ({ ...res, hash: candidate.hash }))
                );
                
                const browserResults = await Promise.all(browserPromises);
                
                for (const res of browserResults) {
                  const { url, status, hash } = res;
                  const oldEntry = committedStatusJson[url] || {};
                  
                  // ç¦»çº¿æ—¶ä¿ç•™æ—§ hash
                  const finalHash = (status === 'Offline' && oldEntry.hash) ? oldEntry.hash : hash;
                  currentResults[url] = { status, hash: finalHash };
                  console.log(`[${getTime()}] ç»“æœ: ${url} -> ${status}`);
                }
              }

              // çŠ¶æ€å¯¹æ¯”ä¸ç¡®è®¤
              let hasConfirmedChanges = false;

              for (const url of urls) {
                const currentEntry = currentResults[url] || { status: 'Offline', hash: '' };
                const committedEntry = committedStatusJson[url] || {};
                
                if (isStateEqual(currentEntry, committedEntry)) {
                  delete pendingChanges[url]; // çŠ¶æ€ç¨³å®šï¼Œæ¸…é™¤å¾…ç¡®è®¤
                  finalStatusJson[url] = committedEntry;
                  continue;
                }

                const pending = pendingChanges[url];
                if (pending && isStateEqual(pending.entry, currentEntry)) {
                  pending.count++;
                  if (pending.count >= CONFIRMATION_THRESHOLD) {
                    // --- ç¡®è®¤å˜åŒ– ---
                    hasConfirmedChanges = true;
                    finalStatusJson[url] = currentEntry;
                    delete pendingChanges[url];
                    
                    const oldStatus = committedEntry.status;
                    const newStatus = currentEntry.status;
                    
                    let msg = '';
                    if (!oldStatus || oldStatus === 'Offline') {
                       if (newStatus !== 'Offline') msg = `ğŸš€ æœåŠ¡å™¨å·²ä¸Šçº¿: <b>${newStatus}</b>`;
                    } else if (newStatus === 'Offline') {
                       msg = `ğŸ”´ æœåŠ¡å™¨å·²ä¸‹çº¿`;
                    } else if (oldStatus !== newStatus) {
                       msg = `ğŸ”„ çŠ¶æ€å˜æ›´: ${oldStatus} -> <b>${newStatus}</b>`;
                    } else if (currentEntry.hash !== committedEntry.hash) {
                       msg = `ğŸ“ ç½‘é¡µæ›´æ–° (Hashå˜åŠ¨)`;
                    }

                    if (msg) {
                      notifications.push(`<a href="${url}">${url}</a> ${msg}`);
                      console.log(`[${getTime()}] ã€ç¡®è®¤å˜æ›´ã€‘${url} ${msg}`);
                    }
                  } else {
                    console.log(`[${getTime()}] â³ å¾…ç¡®è®¤ ${pending.count}/${CONFIRMATION_THRESHOLD}: ${url} -> ${currentEntry.status}`);
                    finalStatusJson[url] = committedEntry; // ä¿æŒæ—§çŠ¶æ€
                  }
                } else {
                  console.log(`[${getTime()}] ğŸ” å‘ç°æ–°å˜åŒ–: ${url} (${committedEntry.status || 'None'} -> ${currentEntry.status})`);
                  pendingChanges[url] = { entry: currentEntry, count: 1 };
                  finalStatusJson[url] = committedEntry;
                }
              }

              // ç”Ÿæˆå¯ç”¨åˆ—è¡¨
              for (const url of urls) {
                const entry = finalStatusJson[url];
                if (entry && entry.status && entry.status !== 'Offline') {
                  const color = entry.status === 'Open' ? 'green' : 'orange';
                  availableServers.push(`<a href="${url}" style="color:${color}">${url}</a> (${entry.status})`);
                }
              }

              if (notifications.length > 0) {
                fs.writeFileSync(STATE_FILE, JSON.stringify(finalStatusJson, null, 2));
                if (commitAndPush()) {
                  const body = `
                    <h3>æœåŠ¡å™¨çŠ¶æ€å˜æ›´æŠ¥å‘Š</h3>
                    ${notifications.join('<br>')}
                    <br><hr>
                    <h4>å½“å‰åœ¨çº¿æœåŠ¡å™¨ (${availableServers.length}):</h4>
                    ${availableServers.length > 0 ? availableServers.join('<br>') : 'æ— åœ¨çº¿æœåŠ¡å™¨'}
                  `;
                  await sendEmail(body);
                }
              } else {
                console.log(`[${getTime()}] æ— éœ€æ¨é€ (è€—æ—¶: ${((Date.now() - loopStart)/1000).toFixed(1)}s)`);
              }

            } catch (err) {
              console.error(`[${getTime()}] å¾ªç¯å¼‚å¸¸:`, err);
            } finally {
              if (browser) await browser.close().catch(() => {});
            }
          }

          // å¯åŠ¨
          (async () => {
            console.log(`[${getTime()}] ç›‘æµ‹å™¨å¯åŠ¨...`);
            await main();
            const intervalId = setInterval(async () => {
              if (Date.now() - START_TIME > MAX_RUNTIME) {
                console.log(`[${getTime()}] è¾¾åˆ°æ—¶é—´é™åˆ¶ï¼Œé€€å‡ºã€‚`);
                clearInterval(intervalId);
                process.exit(0);
              }
              await main();
            }, CHECK_INTERVAL);
          })();
          EOF

          node monitor.js
