name: 3D坦克测试服务器监测器

on:
  schedule:
    # 每 6 小时启动一次新的监测循环（为了接力）
    - cron: '0 */6 * * *'
  workflow_dispatch:

jobs:
  continuous-monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm i playwright nodemailer
          npx playwright install --with-deps chromium

      - name: Run Persistent Monitor
        env:
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
        run: |
          # 创建常驻监控脚本
          cat << 'EOF' > monitor.js
          const { chromium } = require('playwright');
          const fs = require('fs');
          const https = require('https');
          const crypto = require('crypto');
          const { execSync } = require('child_process');
          const nodemailer = require('nodemailer');

          // --- 配置 ---
          const STATE_FILE = 'server_status.json';
          const CHECK_INTERVAL = 5 * 60 * 1000; // 5分钟
          const MAX_RUNTIME = 5.8 * 60 * 60 * 1000; // 5.8小时 (留点缓冲时间给GitHub)
          const START_TIME = Date.now();
          
          // 邮件传输配置
          const transporter = nodemailer.createTransport({
            host: "smtp.qq.com",
            port: 465,
            secure: true,
            auth: {
              user: process.env.MAIL_USERNAME,
              pass: process.env.MAIL_PASSWORD
            }
          });

          // --- 工具函数 ---
          
          // 获取当前时间字符串
          function getTime() {
            return new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
          }

          // 发送 CURL 请求获取状态码和内容 Hash
          function checkCurl(url) {
            return new Promise((resolve) => {
              const req = https.get(url, { rejectUnauthorized: false, timeout: 15000 }, (res) => {
                const { statusCode } = res;
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  const hash = crypto.createHash('sha256').update(data).digest('hex');
                  resolve({ statusCode, hash });
                });
              });
              req.on('error', () => resolve({ statusCode: 0, hash: '' }));
              req.on('timeout', () => { req.destroy(); resolve({ statusCode: 0, hash: '' }); });
            });
          }

          // 使用 Playwright 检测页面交互状态
          async function checkBrowser(url) {
            let browser = null;
            try {
              let targetUrl = url.includes('?') ? url + '&skipEntranceAnyKey' : url + '?skipEntranceAnyKey';
              browser = await chromium.launch();
              const context = await browser.newContext({ userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' });
              const page = await context.newPage();
              await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: 45000 });
              await page.waitForTimeout(10000); // 等待加载
              const content = await page.content();
              
              if (/invite/i.test(content)) return 'Closed';
              return 'Open';
            } catch (e) {
              return 'Offline'; // 浏览器加载失败通常也是 Offline
            } finally {
              if (browser) await browser.close();
            }
          }

          // Git 提交函数
          function commitAndPush() {
            try {
              execSync('git config --global user.name "github-actions[bot]"');
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git add ${STATE_FILE}`);
              
              // 只有当有变更时才提交
              const status = execSync('git status --porcelain').toString();
              if (status) {
                execSync('git commit -m "chore: 更新服务器状态文件 [自动监测]"');
                execSync('git push');
                console.log(`[${getTime()}] Git 状态已更新并推送。`);
              }
            } catch (e) {
              console.error(`[${getTime()}] Git 提交失败:`, e.message);
            }
          }

          // 发送邮件函数
          async function sendEmail(body) {
            try {
              await transporter.sendMail({
                from: `"3D坦克监测器" <${process.env.MAIL_USERNAME}>`,
                to: process.env.MAIL_TO,
                subject: "3D坦克测试服务器状态更新",
                html: `你好，<br><br>${body}<br><br>此邮件由 GitHub Actions 自动监测发送。`
              });
              console.log(`[${getTime()}] 邮件已发送。`);
            } catch (error) {
              console.error(`[${getTime()}] 邮件发送失败:`, error);
            }
          }

          // --- 主逻辑 ---
          async function main() {
            console.log(`[${getTime()}] 监测循环开始...`);

            // 1. 构建 URL 列表
            let urls = [];
            for (let i = 1; i <= 10; i++) {
              urls.push(`https://public-deploy${i}.test-eu.tankionline.com/browser-public/index.html`);
              urls.push(`https://client-review-${i}-public.test-ru.tankionline.com/`);
            }
            urls.push("https://test.ru.tankionline.com/play/?config-template=https://c{server}.ru.tankionline.com/config.xml&balancer=https://balancer.ru.tankionline.com/balancer&resources=https://s.ru.tankionline.com");
            urls.push("https://tankiclassic.com/play/");

            // 2. 读取旧状态
            let oldStatusJson = {};
            if (fs.existsSync(STATE_FILE)) {
              try {
                oldStatusJson = JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
              } catch (e) {}
            }
            let newStatusJson = { ...oldStatusJson }; // 复制一份，基于旧数据修改

            let notifications = [];
            let availableServers = [];

            // 3. 遍历检查 (为了节省资源，即使Nodejs也建议控制并发，这里简单串行或小批次)
            // 第一步：CURL 快速筛选
            let candidates = [];
            for (const url of urls) {
              const { statusCode, hash } = await checkCurl(url);
              // 状态码非 404/403/502/0 视为可能在线
              if (statusCode !== 404 && statusCode !== 403 && statusCode !== 502 && statusCode !== 0) {
                candidates.push({ url, hash });
              } else {
                // 确认为 Offline
                const oldEntry = oldStatusJson[url] || {};
                const oldHash = oldEntry.hash || "";
                
                // 保持旧 Hash (如果之前有)
                const hashToSave = oldHash ? oldHash : hash; 
                
                newStatusJson[url] = { status: "Offline", hash: hashToSave };
                
                // 检查状态变化: Online -> Offline
                if (oldEntry.status && oldEntry.status !== "Offline") {
                   let oldDisplay = oldEntry.status === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                   notifications.push(`- <a href="${url}">${url}</a>: 服务器已下线 (原状态: ${oldDisplay})`);
                }
              }
            }

            // 第二步：Playwright 深度检查 (只检查 CURL 通过的)
            for (const item of candidates) {
              const { url, hash } = item;
              const interactiveStatus = await checkBrowser(url);
              
              const finalStatus = (interactiveStatus === 'Offline') ? 'Offline' : interactiveStatus;
              
              // 准备数据
              const oldEntry = oldStatusJson[url] || {};
              const oldStatus = oldEntry.status || null;
              const oldHash = oldEntry.hash || null;
              
              // 决定保存的 Hash
              let hashToSave = hash;
              if (finalStatus === 'Offline' && oldHash) {
                 hashToSave = oldHash; // 离线了保持旧 Hash
              }

              // 记录到新 JSON
              newStatusJson[url] = { status: finalStatus, hash: hashToSave };

              // 显示状态
              let displayStatus = "";
              let displayStatusBold = "";
              if (finalStatus === "Open") { displayStatus = "开放"; displayStatusBold = "<b>开放</b>"; }
              if (finalStatus === "Closed") { displayStatus = "封闭"; displayStatusBold = "<b>封闭</b>"; }

              if (finalStatus !== "Offline") {
                availableServers.push(`<a href="${url}">${url}</a> (状态: <b>${displayStatus}</b>)`);
              }

              // --- 核心比较逻辑 ---
              let message = "";
              
              // 1. 首次发现
              if (!oldStatus && finalStatus !== "Offline") {
                message = `首次发现服务器 (状态: ${displayStatusBold})`;
              }
              // 2. 状态变化
              else if (oldStatus && finalStatus !== oldStatus) {
                if (oldStatus === "Offline") {
                  // Offline -> Online
                  let baseMsg = "";
                  if (finalStatus === "Open") baseMsg = "服务器已上线并<b>开放</b>";
                  if (finalStatus === "Closed") baseMsg = "服务器已上线，当前为<b>封闭</b>状态";
                  
                  // Hash 对比
                  let hashMsg = "";
                  if (hash !== oldHash) {
                    hashMsg = "，且检测到<b>更新</b>";
                  } else {
                    hashMsg = "，且<b>无更新</b>";
                  }
                  message = baseMsg + hashMsg;
                } 
                else if (finalStatus === "Offline") {
                  // Online -> Offline (这步其实在上面 CURL 部分可能已经被处理，但如果 CURL 通了 Playwright 挂了会走这里)
                  let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                  message = `服务器已下线 (原状态: ${oldDisplay})`;
                }
                else {
                  // Open <-> Closed
                  let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                  message = `服务器状态已从 ${oldDisplay} 变为 ${displayStatusBold}`;
                }
              }
              // 3. 热更新 (在线且 Hash 变了)
              else if (oldStatus !== "Offline" && finalStatus !== "Offline" && oldHash && hash !== oldHash) {
                 message = `网页代码已更新 (状态: ${displayStatusBold})`;
              }

              if (message) {
                notifications.push(`- <a href="${url}">${url}</a>: ${message}`);
              }
            }

            // 4. 后处理：发送通知与保存
            if (notifications.length > 0) {
              console.log(`[${getTime()}] 检测到变化，正在处理通知和保存...`);
              
              // 写入文件
              fs.writeFileSync(STATE_FILE, JSON.stringify(newStatusJson, null, 2));
              
              // 提交 Git
              commitAndPush(); // 需要先提交，保证 git 记录最新

              // 构建邮件内容
              let changeDetails = notifications.join('<br>');
              let availableListHeader = `<br><hr><b>当前已上线的服务器列表 (${availableServers.length} 个):</b><br>`;
              let availableListBody = availableServers.length > 0 ? availableServers.join('<br>') : "目前没有已上线的服务器。";
              let fullBody = `检测到以下服务器状态发生变化：<br>${changeDetails}${availableListHeader}${availableListBody}`;
              
              // 发送邮件
              await sendEmail(fullBody);
            } else {
              console.log(`[${getTime()}] 无状态变化。`);
            }
          }

          // --- 循环控制器 ---
          (async () => {
             // 立即执行一次
             await main();

             const intervalId = setInterval(async () => {
               // 检查是否超时
               if (Date.now() - START_TIME > MAX_RUNTIME) {
                 console.log(`[${getTime()}] 运行时间接近 GitHub 限制，准备退出以重新调度...`);
                 clearInterval(intervalId);
                 process.exit(0); // 正常退出，等待 GitHub 下一次 Schedule
               }
               
               await main();
             }, CHECK_INTERVAL);
          })();
          EOF

          # 运行脚本
          node monitor.js
