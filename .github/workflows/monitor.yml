name: 3D坦克测试服务器监测器

on:
  schedule:
    # 每 5 小时启动一次新任务 (配合脚本内的循环运行，实现全天候监测)
    - cron: '0 */5 * * *'
  workflow_dispatch:

jobs:
  continuous-monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 需要写入权限来保存状态文件
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        # 强制安装 p-limit@3 以兼容 CommonJS
        run: |
          npm i playwright nodemailer p-limit@3
          npx playwright install --with-deps chromium

      - name: Run Persistent Monitor
        env:
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
        run: |
          cat << 'EOF' > monitor.js
          const { chromium } = require('playwright');
          const fs = require('fs');
          const https = require('https');
          const crypto = require('crypto');
          const { execSync } = require('child_process');
          const nodemailer = require('nodemailer');
          const pLimit = require('p-limit');

          // --- 配置 ---
          const STATE_FILE = 'server_status.json';
          // 每 3 分钟检测一次
          const CHECK_INTERVAL = 2 * 60 * 1000; 
          // 任务最长运行 5.8 小时，给 GitHub Actions 留出清理时间
          const MAX_RUNTIME = 5.8 * 60 * 60 * 1000; 
          
          const START_TIME = Date.now();
          const BROWSER_CONCURRENCY = 5; 

          // 【核心修复】全局变量：存储“待确认”的变化
          // 只有连续两次检测结果一致，才视为有效变化
          let pendingChanges = {};

          const transporter = nodemailer.createTransport({
            host: "smtp.qq.com",
            port: 465,
            secure: true,
            auth: {
              user: process.env.MAIL_USERNAME,
              pass: process.env.MAIL_PASSWORD
            }
          });

          function getTime() {
            return new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
          }

          // 使用 Curl (https.get) 获取哈希，过滤静态文件
          function checkCurl(url) {
            return new Promise((resolve) => {
              const req = https.get(url, { rejectUnauthorized: false, timeout: 10000 }, (res) => {
                const { statusCode } = res;
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  // 计算页面内容 Hash，用于判断是否有更新
                  const hash = crypto.createHash('sha256').update(data).digest('hex');
                  resolve({ url, statusCode, hash });
                });
              });
              req.on('error', () => resolve({ url, statusCode: 0, hash: '' }));
              req.on('timeout', () => { req.destroy(); resolve({ url, statusCode: 0, hash: '' }); });
            });
          }

          // 使用浏览器模拟访问，判断是 Open 还是 Closed (Invite)
          async function checkBrowserPage(context, url) {
            let page = null;
            try {
              // 添加参数跳过入口动画，加快加载
              let targetUrl = url.includes('?') ? url + '&skipEntranceAnyKey' : url + '?skipEntranceAnyKey';
              page = await context.newPage();
              await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });
              // 等待加载，避免网络波动导致的误判
              await page.waitForTimeout(8000); 
              const content = await page.content();
              
              // 关键词判定逻辑
              if (/invite/i.test(content)) return { url, status: 'Closed' };
              return { url, status: 'Open' };
            } catch (e) {
              return { url, status: 'Offline' };
            } finally {
              if (page) await page.close().catch(() => {});
            }
          }

          function commitAndPush() {
            try {
              execSync('git config --global user.name "github-actions[bot]"');
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git add ${STATE_FILE}`);
              const status = execSync('git status --porcelain').toString();
              if (status) {
                execSync('git commit -m "chore: 更新服务器状态文件 [skip ci]"');
                execSync('git push');
                console.log(`[${getTime()}] Git 状态已更新并推送。`);
              }
            } catch (e) {
              console.error(`[${getTime()}] Git 提交失败:`, e.message);
            }
          }

          async function sendEmail(body) {
            try {
              await transporter.sendMail({
                from: `"3D坦克测试服监测" <${process.env.MAIL_USERNAME}>`,
                to: process.env.MAIL_TO,
                subject: "3D坦克测试服务器状态变动",
                html: `你好，<br><br>${body}<br><br>此邮件由 GitHub Actions 自动监测发送。`
              });
              console.log(`[${getTime()}] 邮件已发送。`);
            } catch (error) {
              console.error(`[${getTime()}] 邮件发送失败:`, error);
            }
          }

          async function main() {
            const loopStart = Date.now();
            console.log(`[${getTime()}] 开始新一轮检测...`);

            let urls = [];
            // 监测 Deploy 1-10
            for (let i = 1; i <= 10; i++) {
              urls.push(`https://public-deploy${i}.test-eu.tankionline.com/browser-public/index.html`);
            }
            // 监测 RU 测试服和经典服
            urls.push("https://test.ru.tankionline.com/play/?config-template=https://c{server}.ru.tankionline.com/config.xml&balancer=https://balancer.ru.tankionline.com/balancer&resources=https://s.ru.tankionline.com");
            urls.push("https://tankiclassic.com/play/");

            // 读取已保存的状态 (Committed State)
            let committedStatusJson = {};
            if (fs.existsSync(STATE_FILE)) {
              try { committedStatusJson = JSON.parse(fs.readFileSync(STATE_FILE, 'utf8')); } catch (e) {}
            }
            
            // 准备新的状态对象
            let finalStatusJson = { ...committedStatusJson }; 
            let notifications = [];
            let availableServers = [];

            // 第一阶段: 快速 Curl 筛选
            const curlResults = await Promise.all(urls.map(url => checkCurl(url)));
            let candidatesForBrowser = [];
            let currentResults = {}; 

            // 处理 Curl 结果
            for (const res of curlResults) {
              const { url, statusCode, hash } = res;
              // 只有非错误状态码才启动浏览器进一步检测
              if (statusCode !== 404 && statusCode !== 403 && statusCode !== 502 && statusCode !== 0) {
                candidatesForBrowser.push({ url, hash });
              } else {
                // Curl 判定为离线
                const oldEntry = committedStatusJson[url] || {};
                const oldHash = oldEntry.hash || "";
                // 离线时保留最后一次已知的 Hash，以便下次上线对比是否更新
                const hashToSave = oldHash ? oldHash : hash; 
                currentResults[url] = { status: "Offline", hash: hashToSave };
              }
            }

            // 第二阶段: 浏览器检测 (仅针对 Curl 存活的链接)
            if (candidatesForBrowser.length > 0) {
              let browser = null;
              try {
                browser = await chromium.launch();
                const context = await browser.newContext({ userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' });
                const limit = pLimit(BROWSER_CONCURRENCY);
                
                const browserPromises = candidatesForBrowser.map(candidate => {
                  return limit(() => checkBrowserPage(context, candidate.url).then(res => ({ ...res, hash: candidate.hash })));
                });
                const browserResults = await Promise.all(browserPromises);

                for (const res of browserResults) {
                  const { url, status: finalStatus, hash } = res;
                  const oldEntry = committedStatusJson[url] || {};
                  const oldHash = oldEntry.hash || null;
                  
                  let hashToSave = hash;
                  // 如果浏览器判定离线 (超时等)，也保留旧 Hash
                  if (finalStatus === 'Offline' && oldHash) hashToSave = oldHash; 
                  
                  currentResults[url] = { status: finalStatus, hash: hashToSave };
                }
              } catch (err) {
                console.error("浏览器检测出错:", err);
              } finally {
                if (browser) await browser.close();
              }
            }

            // --- 【核心修复逻辑】双重确认 (防抖动) ---
            let hasConfirmedChanges = false;

            for (const url of urls) {
              const currentEntry = currentResults[url] || { status: 'Offline', hash: '' };
              const committedEntry = committedStatusJson[url] || {};
              
              const isSame = (a, b) => a.status === b.status && a.hash === b.hash;

              if (isSame(currentEntry, committedEntry)) {
                // 1. 状态没变：清除由于网络波动产生的“待确认”记录
                if (pendingChanges[url]) delete pendingChanges[url];
                finalStatusJson[url] = committedEntry; 
              } else {
                // 2. 状态变了
                if (pendingChanges[url] && isSame(pendingChanges[url], currentEntry)) {
                  // A. 【确认变化】: 当前状态与 3 分钟前记录的“待确认”状态一致
                  hasConfirmedChanges = true;
                  finalStatusJson[url] = currentEntry; 
                  delete pendingChanges[url]; // 移除待确认

                  // --- 生成通知逻辑 ---
                  const oldStatus = committedEntry.status || null;
                  const oldHash = committedEntry.hash || null;
                  const finalStatus = currentEntry.status;
                  const hash = currentEntry.hash;

                  let displayStatus = "";
                  let displayStatusBold = "";
                  if (finalStatus === "Open") { displayStatus = "开放"; displayStatusBold = "<b>开放</b>"; }
                  if (finalStatus === "Closed") { displayStatus = "封闭"; displayStatusBold = "<b>封闭</b>"; }

                  let message = "";
                  
                  // 情况 1: 全新发现
                  if (!oldStatus && finalStatus !== "Offline") {
                    message = `首次发现服务器 (状态: ${displayStatusBold})`;
                  }
                  // 情况 2: 状态改变 (Offline -> Online 或 Open <-> Closed)
                  else if (oldStatus && finalStatus !== oldStatus) {
                    if (oldStatus === "Offline") {
                      // 从离线恢复
                      let baseMsg = "";
                      if (finalStatus === "Open") baseMsg = "服务器已上线并<b>开放</b>";
                      if (finalStatus === "Closed") baseMsg = "服务器已上线，当前为<b>封闭</b>状态";
                      
                      // 只有从离线恢复时，才对比 Hash 判断是否有更新
                      let hashMsg = (oldHash && hash !== oldHash) ? "，且检测到<b>更新</b>" : "，且<b>无更新</b>";
                      message = baseMsg + hashMsg;
                    } 
                    else if (finalStatus === "Offline") {
                      // 掉线
                      let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                      message = `服务器已下线 (原状态: ${oldDisplay})`;
                    }
                    else {
                      // 开放 <-> 封闭 切换
                      let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                      message = `服务器状态已从 ${oldDisplay} 变为 ${displayStatusBold}`;
                    }
                  }
                  // 情况 3: 状态没变 (例如一直是 Open)，但 Hash 变了 -> 热更新
                  else if (oldStatus !== "Offline" && finalStatus !== "Offline" && oldHash && hash !== oldHash) {
                     message = `网页代码已更新 (状态: ${displayStatusBold})`;
                  }
                  
                  if (message) notifications.push(`- <a href="${url}">${url}</a>: ${message}`);

                } else {
                  // B. 【首次发现变化】: 放入待确认列表，不报警
                  // 只有当这个状态持续到下一次检测 (3分钟后) 时，才会发邮件
                  console.log(`[${getTime()}] 发现潜在变化: ${url} (原: ${committedEntry.status} -> 新: ${currentEntry.status})。等待确认...`);
                  pendingChanges[url] = currentEntry;
                  finalStatusJson[url] = committedEntry; // 保持文件不变，防止误报
                }
              }

              // 统计可用服务器 (用于邮件底部)
              const statusToShow = finalStatusJson[url] || {};
              if (statusToShow.status && statusToShow.status !== "Offline") {
                 let disp = statusToShow.status === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                 availableServers.push(`<a href="${url}">${url}</a> (状态: ${disp})`);
              }
            }

            // 发送通知并保存
            if (notifications.length > 0) {
              console.log(`[${getTime()}] 确认状态变化，发送通知并保存。`);
              fs.writeFileSync(STATE_FILE, JSON.stringify(finalStatusJson, null, 2));
              commitAndPush();
              let changeDetails = notifications.join('<br>');
              let availableListHeader = `<br><hr><b>当前在线服务器列表:</b><br>`;
              let availableListBody = availableServers.length > 0 ? availableServers.join('<br>') : "无。";
              let fullBody = `检测到状态变化：<br>${changeDetails}${availableListHeader}${availableListBody}`;
              await sendEmail(fullBody);
            } else {
              const pendingCount = Object.keys(pendingChanges).length;
              console.log(`[${getTime()}] 无确认变化。(${pendingCount} 个状态待确认)`);
            }
          }

          // 启动循环
          (async () => {
             await main(); // 立即执行一次
             const intervalId = setInterval(async () => {
               if (Date.now() - START_TIME > MAX_RUNTIME) {
                 console.log(`[${getTime()}] 运行时间结束，退出。`);
                 clearInterval(intervalId);
                 process.exit(0);
               }
               await main();
             }, CHECK_INTERVAL);
          })();
          EOF

          node monitor.js
