name: 3D坦克测试服务器监测器

on:
  schedule:
    - cron: '0 */5 * * *'
  workflow_dispatch:

jobs:
  continuous-monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm i playwright nodemailer p-limit@3
          npx playwright install --with-deps chromium

      - name: Run Persistent Monitor
        env:
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          MAIL_TO: ${{ secrets.MAIL_TO }}
        run: |
          cat << 'EOF' > monitor.js
          const { chromium } = require('playwright');
          const fs = require('fs');
          const https = require('https');
          const crypto = require('crypto');
          const { execSync } = require('child_process');
          const nodemailer = require('nodemailer');
          const pLimit = require('p-limit');

          // --- 配置 ---
          const STATE_FILE = 'server_status.json';
          const CHECK_INTERVAL = 3 * 60 * 1000; // 3分钟
          const MAX_RUNTIME = 5.8 * 60 * 60 * 1000; // 5.8小时
          const START_TIME = Date.now();
          const BROWSER_CONCURRENCY = 3; 
          const CONFIRMATION_THRESHOLD = 2; 

          // 记录检测次数
          let pendingChanges = {};

          const transporter = nodemailer.createTransport({
            host: "smtp.qq.com",
            port: 465,
            secure: true,
            auth: {
              user: process.env.MAIL_USERNAME,
              pass: process.env.MAIL_PASSWORD
            }
          });

          function getTime() {
            return new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
          }

          function checkCurl(url) {
            return new Promise((resolve) => {
              const req = https.get(url, { 
                rejectUnauthorized: false, 
                timeout: 15000,
                headers: {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
              }, (res) => {
                const { statusCode } = res;
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  const isAlive = statusCode >= 200 && statusCode < 300 && data.length > 100;
                  const hash = isAlive ? crypto.createHash('sha256').update(data).digest('hex') : '';
                  resolve({ 
                    url, 
                    statusCode, 
                    hash, 
                    isAlive,
                    dataLength: data.length 
                  });
                });
              });
              
              req.on('error', (err) => {
                console.log(`[${getTime()}] Curl 错误 ${url}: ${err.message}`);
                resolve({ url, statusCode: 0, hash: '', isAlive: false, dataLength: 0 });
              });
              
              req.on('timeout', () => {
                req.destroy();
                console.log(`[${getTime()}] Curl 超时 ${url}`);
                resolve({ url, statusCode: 0, hash: '', isAlive: false, dataLength: 0 });
              });
            });
          }

          // 【修复】增强稳定性的浏览器检测函数
          async function checkBrowserPage(browser, url) {
            let page = null;
            const context = await browser.newContext({
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.0.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.0',
              viewport: { width: 1280, height: 720 },
              ignoreHTTPSErrors: true
            });
            
            try {
              const targetUrl = url.includes('?') 
                ? url + '&skipEntranceAnyKey' 
                : url + '?skipEntranceAnyKey';
              
              page = await context.newPage();
              
              // 1. 访问页面
              const response = await page.goto(targetUrl, { 
                waitUntil: 'commit', // 改为 commit，避免一直等待 networkidle 超时
                timeout: 45000 
              });
              
              if (!response || response.status() >= 400) {
                return { url, status: 'Offline', httpStatus: response?.status() || 0 };
              }
              
              // 2. 等待加载稳定
              try {
                await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});
                await page.waitForTimeout(3000); 
              } catch (e) {}

              // 3. 多维度检测邀请界面 (增加异常处理)
              const checks = await Promise.all([
                // Locator 检测 (自动重试，较稳定)
                page.locator('text=/invitation/i').count().catch(() => 0),
                page.locator('text=/邀请/i').count().catch(() => 0),
                page.locator('[class*="invitation"]').count().catch(() => 0),
                
                // 【修复】page.content() 包裹 try-catch，防止页面跳转时报错崩溃
                (async () => {
                  try {
                    const html = await page.content();
                    return /invitation|邀请码|invite/i.test(html);
                  } catch (err) {
                    // 页面正在跳转或销毁，忽略此次 content 检查
                    return false; 
                  }
                })()
              ]);
              
              const hasInvitation = checks.some(c => c > 0 || c === true);
              
              return { 
                url, 
                status: hasInvitation ? 'Closed' : 'Open',
                httpStatus: response.status()
              };
              
            } catch (e) {
              console.log(`[${getTime()}] 浏览器检测错误 ${url}: ${e.message}`);
              // 如果出错但不是离线，为了安全起见标记为 Closed (或者根据你的需求标记为 Offline)
              // 这里返回 Offline 并带上错误信息
              return { url, status: 'Offline', error: e.message };
            } finally {
              await context.close().catch(() => {});
            }
          }

          function commitAndPush() {
            try {
              execSync('git pull --rebase origin main || git pull --rebase origin master || true', { stdio: 'pipe' });
              execSync('git config --global user.name "github-actions[bot]"');
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git add ${STATE_FILE}`);
              
              const status = execSync('git status --porcelain').toString();
              if (status) {
                execSync('git commit -m "chore: 更新服务器状态文件"');
                execSync('git push');
                console.log(`[${getTime()}] Git 状态已更新并推送。`);
                return true;
              }
              return false;
            } catch (e) {
              console.error(`[${getTime()}] Git 提交失败:`, e.message);
              return false;
            }
          }

          async function sendEmail(body) {
            try {
              await transporter.sendMail({
                from: `"3D坦克测试服监测器" <${process.env.MAIL_USERNAME}>`,
                to: process.env.MAIL_TO,
                subject: "3D坦克测试服务器状态更新",
                html: `你好，<br><br>${body}<br><br>此邮件由 GitHub Actions 自动监测发送。`
              });
              console.log(`[${getTime()}] 邮件已发送。`);
            } catch (error) {
              console.error(`[${getTime()}] 邮件发送失败:`, error);
            }
          }

          function isStateEqual(a, b) {
            if (!a || !b) return false;
            return a.status === b.status && a.hash === b.hash;
          }

          async function main() {
            const loopStart = Date.now();
            console.log(`\n[${getTime()}] ========== 监测循环开始 ==========`);

            const urls = [];
            for (let i = 1; i <= 10; i++) {
              urls.push(`https://public-deploy${i}.test-eu.tankionline.com/browser-public/index.html`);
            }
            urls.push(
              "https://test.ru.tankionline.com/play/?config-template=https://c{server}.ru.tankionline.com/config.xml&balancer=https://balancer.ru.tankionline.com/balancer&resources=https://s.ru.tankionline.com",
              "https://tankiclassic.com/play/"
            );

            let committedStatusJson = {};
            let retries = 3;
            while (retries > 0) {
              try {
                if (fs.existsSync(STATE_FILE)) {
                  const content = fs.readFileSync(STATE_FILE, 'utf8');
                  committedStatusJson = JSON.parse(content);
                }
                break;
              } catch (e) {
                console.error(`[${getTime()}] 读取状态文件失败，重试...`);
                retries--;
                await new Promise(r => setTimeout(r, 1000));
              }
            }

            let finalStatusJson = { ...committedStatusJson };
            let notifications = [];
            let availableServers = [];
            let browser = null;
            
            // 初始化结果容器，避免 ReferenceError
            let currentResults = {};

            try {
              // Phase 1: Curl 快速筛选
              console.log(`[${getTime()}] Phase 1: Curl 检测 ${urls.length} 个 URL...`);
              const curlResults = await Promise.all(urls.map(url => checkCurl(url)));
              
              const candidatesForBrowser = [];

              for (const res of curlResults) {
                const { url, isAlive, hash, statusCode, dataLength } = res;
                
                if (isAlive) {
                  candidatesForBrowser.push({ url, hash });
                  console.log(`[${getTime()}] Curl 存活: ${url} (状态: ${statusCode}, 大小: ${dataLength})`);
                } else {
                  const oldEntry = committedStatusJson[url] || {};
                  // Curl 失败直接标记为 Offline
                  currentResults[url] = { 
                    status: "Offline", 
                    hash: oldEntry.hash || hash 
                  };
                }
              }

              // Phase 2: 浏览器深度检测
              if (candidatesForBrowser.length > 0) {
                console.log(`[${getTime()}] Phase 2: 浏览器检测 ${candidatesForBrowser.length} 个候选...`);
                
                browser = await chromium.launch({ 
                  headless: true,
                  args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
                });
                
                const limit = pLimit(BROWSER_CONCURRENCY);
                const browserPromises = candidatesForBrowser.map(candidate => 
                  limit(() => checkBrowserPage(browser, candidate.url).then(res => ({
                    ...res,
                    hash: candidate.hash
                  })))
                );
                
                const browserResults = await Promise.all(browserPromises);
                
                for (const res of browserResults) {
                  const { url, status, hash, error } = res;
                  const oldEntry = committedStatusJson[url] || {};
                  
                  let finalStatus = status;
                  // 如果浏览器检测报错但 curl 是活的，我们不能确定它是否 Closed
                  // 这里做一个保守策略：如果报错了，大概率是页面加载太慢或跳转太乱，暂时视为 Closed 防止漏报
                  if (status === 'Offline' && !error) {
                    finalStatus = 'Closed';
                  }
                  
                  const hashToSave = finalStatus === 'Offline' && oldEntry.hash 
                    ? oldEntry.hash 
                    : hash;
                  
                  currentResults[url] = { status: finalStatus, hash: hashToSave };
                  console.log(`[${getTime()}] 浏览器结果: ${url} -> ${finalStatus}`);
                }
              }

              // 状态确认逻辑
              let hasConfirmedChanges = false;

              for (const url of urls) {
                const currentEntry = currentResults[url] || { status: 'Offline', hash: '' };
                const committedEntry = committedStatusJson[url] || {};
                
                // 状态未变
                if (isStateEqual(currentEntry, committedEntry)) {
                  if (pendingChanges[url]) {
                    delete pendingChanges[url];
                  }
                  finalStatusJson[url] = committedEntry;
                  continue;
                }

                // 状态变化，检查确认计数
                const pending = pendingChanges[url];
                
                if (pending && isStateEqual(pending.entry, currentEntry)) {
                  pending.count++;
                  
                  if (pending.count >= CONFIRMATION_THRESHOLD) {
                    hasConfirmedChanges = true;
                    finalStatusJson[url] = currentEntry;
                    delete pendingChanges[url];
                    
                    const oldStatus = committedEntry.status || null;
                    const oldHash = committedEntry.hash || null;
                    const finalStatus = currentEntry.status;
                    const hash = currentEntry.hash;

                    let displayStatus = "";
                    let displayStatusBold = "";
                    if (finalStatus === "Open") { displayStatus = "开放"; displayStatusBold = "<b>开放</b>"; }
                    if (finalStatus === "Closed") { displayStatus = "封闭"; displayStatusBold = "<b>封闭</b>"; }

                    let message = "";
                    if (!oldStatus && finalStatus !== "Offline") {
                      message = `首次发现服务器 (状态: ${displayStatusBold})`;
                    }
                    else if (oldStatus && finalStatus !== oldStatus) {
                      if (oldStatus === "Offline") {
                        let baseMsg = finalStatus === "Open" ? "服务器已上线并<b>开放</b>" : "服务器已上线，当前为<b>封闭</b>状态";
                        let hashMsg = (hash !== oldHash) ? "，且检测到<b>更新</b>" : "，且<b>无更新</b>";
                        message = baseMsg + hashMsg;
                      } 
                      else if (finalStatus === "Offline") {
                        let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                        message = `服务器已下线 (原状态: ${oldDisplay})`;
                      }
                      else {
                        let oldDisplay = oldStatus === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                        message = `服务器状态已从 ${oldDisplay} 变为 ${displayStatusBold}`;
                      }
                    }
                    else if (oldStatus !== "Offline" && finalStatus !== "Offline" && oldHash && hash !== oldHash) {
                      message = `网页代码已更新 (状态: ${displayStatusBold})`;
                    }
                    
                    if (message) {
                      notifications.push(`- <a href="${url}">${url}</a>: ${message}`);
                      console.log(`[${getTime()}] 【确认变化】${url}: ${message}`);
                    }
                  } else {
                    console.log(`[${getTime()}] 待确认 ${pending.count}/${CONFIRMATION_THRESHOLD}: ${url}`);
                    finalStatusJson[url] = committedEntry;
                  }
                } else {
                  console.log(`[${getTime()}] 发现潜在变化: ${url} (原: ${committedEntry.status} -> 新: ${currentEntry.status})`);
                  pendingChanges[url] = { entry: currentEntry, count: 1 };
                  finalStatusJson[url] = committedEntry;
                }
              }

              // 生成可用服务器列表
              for (const url of urls) {
                const statusEntry = finalStatusJson[url];
                if (statusEntry && statusEntry.status && statusEntry.status !== "Offline") {
                  const disp = statusEntry.status === 'Open' ? '<b>开放</b>' : '<b>封闭</b>';
                  availableServers.push(`<a href="${url}">${url}</a> (状态: ${disp})`);
                }
              }

              // 处理通知和 Git
              if (notifications.length > 0) {
                console.log(`[${getTime()}] 发送 ${notifications.length} 条通知...`);
                fs.writeFileSync(STATE_FILE, JSON.stringify(finalStatusJson, null, 2));
                
                if (commitAndPush()) {
                  const changeDetails = notifications.join('<br>');
                  const availableListHeader = `<br><hr><b>当前已上线的服务器列表 (${availableServers.length} 个):</b><br>`;
                  const availableListBody = availableServers.length > 0 
                    ? availableServers.join('<br>') 
                    : "目前没有已上线的服务器。";
                  const fullBody = `检测到以下服务器状态发生变化：<br>${changeDetails}${availableListHeader}${availableListBody}`;
                  await sendEmail(fullBody);
                }
              } else {
                const pendingCount = Object.keys(pendingChanges).length;
                const duration = ((Date.now() - loopStart) / 1000).toFixed(1);
                const pendingMsg = pendingCount > 0 ? ` (有 ${pendingCount} 个状态待确认)` : "";
                console.log(`[${getTime()}] 无已确认的状态变化。${pendingMsg} (耗时: ${duration}秒)`);
                
                // 清理过期的待确认状态
                const now = Date.now();
                for (const [url, data] of Object.entries(pendingChanges)) {
                  if (data.timestamp && (now - data.timestamp > 10 * 60 * 1000)) {
                    delete pendingChanges[url];
                    console.log(`[${getTime()}] 清理过期待确认: ${url}`);
                  } else if (!data.timestamp) {
                    pendingChanges[url].timestamp = now;
                  }
                }
              }

            } catch (err) {
              console.error(`[${getTime()}] 主循环错误:`, err);
            } finally {
              if (browser) {
                await browser.close().catch(() => {});
              }
            }
          }

          (async () => {
            console.log(`[${getTime()}] 监测器启动，运行时间限制: ${MAX_RUNTIME/3600000}小时`);
            await main();
            const intervalId = setInterval(async () => {
              const elapsed = Date.now() - START_TIME;
              if (elapsed > MAX_RUNTIME) {
                console.log(`[${getTime()}] 运行时间接近限制，退出...`);
                clearInterval(intervalId);
                process.exit(0);
              }
              await main();
            }, CHECK_INTERVAL);
          })();
          EOF

          node monitor.js
