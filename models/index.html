<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanki Model Showcase</title>
    <style>
        /* Prevent FOUT */
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@400;500;700&display=swap');
        body.fouc-loading { opacity: 0; pointer-events: none; }
        body { transition: opacity 0.3s ease-in; opacity: 1; }
        * {
        -webkit-tap-highlight-color: transparent;
        }
        /* Design Tokens - Dark Theme */
        :root {
            /* Palette */
            --md-sys-color-background: #00141e;
            --md-sys-color-surface: #00141e;
            --md-sys-color-surface-container-low: #001d26;
            --md-sys-color-surface-container: #00222b;
            --md-sys-color-surface-container-high: #002b37;
            --md-sys-color-surface-container-highest: #003644;
            
            --md-sys-color-primary: #76FF33;
            --md-sys-color-on-primary: #00390a;
            --md-sys-color-primary-container: #005313;
            --md-sys-color-on-primary-container: #8aff66;
            
            --md-sys-color-outline: #8d9da5;
            --md-sys-color-outline-variant: #40484c;
            
            --md-sys-color-on-surface: #e1e2e5;
            --md-sys-color-on-surface-variant: #bfc8cc;

            /* State Layers */
            --md-state-hover: rgba(255,255,255,0.08);
            --md-state-focus: rgba(255,255,255,0.12);
            --md-state-primary-hover: rgba(118, 255, 51, 0.08);
            
            /* Shape */
            --shape-l: 24px;
            --shape-m: 12px;
            --shape-s: 4px;
            
            /* Assets */
            --hull: #80cbc4; 
            --turret: #ffcc80; 
            --scene: #ffab91; 
        }

        body { 
            margin: 0; overflow: hidden; font-family: 'Rubik', 'M PLUS 1p'; 
            background: var(--md-sys-color-background); color: var(--md-sys-color-on-surface); 
            touch-action: none; 
        }
        
        /* Typography */
        h3 { letter-spacing: 0; line-height: 24px; }
        p, span, div { letter-spacing: 0.25px; }
        
        #top-bar { position: absolute; top: 0; left: 0; right: 0; padding: 24px; background: linear-gradient(to bottom, #00141ee6, transparent); pointer-events: none; z-index: 10; display:flex; flex-direction:column; gap:4px; }
        .app-title { font-weight: 400; font-size: 22px; color: var(--md-sys-color-on-surface); }

        #toast { 
            position: absolute; top: 24px; left: 50%; transform: translateX(-50%) translateY(-20px); 
            background: #2b3135; color: #f1f0f4;
            padding: 14px 24px; border-radius: 100px; opacity: 0; transition: 0.4s cubic-bezier(0.2,0,0,1); 
            pointer-events: none; z-index: 200; box-shadow: 0 4px 8px rgba(0,0,0,0.3); font-size: 14px; 
            display:flex; align-items:center; gap:8px; 
        }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        /* M3 FAB (Standard) */
        #fab { 
            position: absolute; bottom: 24px; right: 24px; 
            width: 56px; height: 56px; border-radius: 16px; 
            background: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); 
            border: none; box-shadow: 0 4px 8px 3px rgba(0,0,0,0.15); 
            display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; 
            transition: 0.2s cubic-bezier(0.2,0,0,1); 
        }
        #fab:hover { background: color-mix(in srgb, var(--md-sys-color-primary-container), white 10%); box-shadow: 0 6px 10px 4px rgba(0,0,0,0.2); transform:scale(1.02); }
        #fab svg { width: 24px; fill: currentColor; }

        /* M3 Navigation Drawer */
        #drawer { 
            position: absolute; top: 0; right: 0; bottom: 0; width: 360px; max-width: 95vw; 
            background: var(--md-sys-color-surface-container-low); 
            border-top-left-radius: var(--shape-l); border-bottom-left-radius: var(--shape-l);
            display: none; z-index: 90; 
            flex-direction: column; box-shadow: -4px 0 12px rgba(0,0,0,0.3);
            border-left: 1px solid rgba(255,255,255,0.05);
        }
        #drawer.open { display: flex; }
        
        /* M3 Segmented Button (Tabs) */
        .tab-group { 
            display: flex; margin: 16px; 
            border: 1px solid var(--md-sys-color-outline); 
            border-radius: 100px; overflow: hidden; height: 40px;
            flex-shrink: 0;
        }
        .tab-btn { 
            flex: 1; display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: 500; cursor: pointer; color: var(--md-sys-color-on-surface-variant); 
            transition: 0.2s; letter-spacing: 0.1px;
            border-right: 1px solid var(--md-sys-color-outline);
            position: relative;
        }
        .tab-btn:last-child { border-right: none; }
        .tab-btn.active { 
            background: var(--md-sys-color-primary-container); 
            color: var(--md-sys-color-on-primary-container); 
        }
        .tab-btn:hover:not(.active) { background: var(--md-state-hover); color: var(--md-sys-color-on-surface); }
        
        .drawer-content { flex: 1; overflow-y: auto; padding: 0 16px 20px; display: none; }
        .drawer-content.active { display: block; }

        /* M3 Outlined Card */
        .m3-card { 
            background: transparent; 
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--shape-m); 
            padding: 16px; margin-bottom: 16px; 
            transition: 0.2s;
            position: relative;
        }
        .m3-card:hover { border-color: var(--md-sys-color-outline); }

        .card-title { 
            font-size: 11px; font-weight: 500; letter-spacing: 0.5px; 
            text-transform: uppercase; margin-bottom: 16px; 
            display:flex; align-items:center; gap:8px; opacity: 0.9;
        }
        
        .slot-display { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
        .slot-icon { 
            width: 56px; height: 56px; border-radius: 16px; 
            background: var(--md-sys-color-surface-container-highest); 
            display: flex; align-items: center; justify-content: center; 
            color: var(--md-sys-color-on-surface-variant); 
        }
        .slot-icon svg { width: 28px; fill: currentColor; }
        .slot-text h3 { margin: 0; font-size: 16px; font-weight: 400; color: var(--md-sys-color-on-surface); }
        .slot-text p { margin: 4px 0 0; font-size: 12px; color: var(--md-sys-color-on-surface-variant); }

        /* --- M3 Custom Select --- */
        .control-col { display: flex; flex-direction: column; gap: 16px; }

        .m3-custom-select {
            position: relative;
            background: var(--md-sys-color-surface-container-highest);
            border-radius: 4px 4px 0 0;
            height: 56px;
            border-bottom: 1px solid var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            transition: background 0.2s;
        }
        .m3-custom-select:hover { background: color-mix(in srgb, var(--md-sys-color-surface-container-highest), white 5%); }
        .m3-custom-select::after {
            content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px;
            background: var(--md-sys-color-primary); transform: scaleX(0); transition: 0.2s;
            z-index: 2;
        }
        .m3-custom-select.active::after { transform: scaleX(1); }

        .select-label {
            position: absolute; top: 8px; left: 52px;
            font-size: 12px; color: var(--md-sys-color-primary);
            pointer-events: none; letter-spacing: 0.4px;
        }
        
        .select-trigger {
            display: flex; align-items: center; width: 100%; height: 100%;
            padding: 20px 16px 4px; box-sizing: border-box;
        }
        
        .select-icon-box {
            position: absolute; left: 12px; top: 50%; transform: translateY(-50%);
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
        }
        /* 支持 IMG 标签保持原色，支持 SVG 保持样式 */
        .select-icon-box svg, .select-icon-box img { width: 100%; height: 100%; object-fit: contain; } 
        
        .select-text {
            margin-left: 36px; font-size: 16px; color: var(--md-sys-color-on-surface);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;
        }
        .select-arrow {
            position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
            color: var(--md-sys-color-on-surface-variant);
            transition: transform 0.2s;
            display: flex; align-items: center; justify-content: center;
            width: 24px; height: 24px; pointer-events: none;
        }
        .select-arrow svg { fill: currentColor; width: 24px; height: 24px; }
        .m3-custom-select.active .select-arrow { transform: translateY(-50%) rotate(180deg); }

        /* Dropdown Menu */
        .m3-options-panel {
            display: none; position: absolute; top: 100%; left: 0; right: 0;
            background: var(--md-sys-color-surface-container-high);
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            max-height: 280px; overflow-y: auto;
            z-index: 200; margin-top: 1px;
            padding: 4px 0;
        }
        .m3-options-panel.show { display: block; animation: slideDown 0.15s ease-out; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }

        .m3-option-row {
            display: flex; align-items: center; gap: 12px;
            padding: 10px 16px;
            cursor: pointer; transition: 0.1s;
            color: var(--md-sys-color-on-surface);
        }
        .m3-option-row:hover, .m3-option-row.selected {
            background: var(--md-state-hover);
        }
        .m3-option-row.selected { 
            background: var(--md-sys-color-surface-container-highest); 
            color: var(--md-sys-color-primary); 
        }
        /* 仅对内联 SVG (装备) 强制变色，对 IMG (皮肤) 不生效，保护皮肤颜色 */
        .m3-option-row.selected .opt-icon svg { fill: var(--md-sys-color-primary); }

        .opt-icon { width: 28px; height: 28px; flex-shrink: 0; display:flex; align-items:center; justify-content:center; }
        .opt-icon svg, .opt-icon img { width: 100%; height: 100%; object-fit: contain; }

        /* Hidden Native Select */
        .native-select-hidden { display: none; }

        .spinner { width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--md-sys-color-primary); border-radius: 50%; animation: spin 1s linear infinite; position: absolute; right: 16px; top: 20px; display: none; background:var(--md-sys-color-surface-container-highest); z-index:2;}
        @keyframes spin { to { transform: rotate(360deg); } }
        .m3-custom-select.loading .spinner { display: block; }

        /* M3 Switch */
        .beta-toggle { 
            display: flex; align-items: center; justify-content: space-between; 
            padding: 8px 0; cursor: pointer; user-select: none; margin-bottom:8px;
        }
        .beta-label { font-size: 14px; font-weight: 500; color: var(--md-sys-color-on-surface); }
        .beta-switch { 
            width: 52px; height: 32px; 
            background: var(--md-sys-color-surface-container-highest); 
            border: 2px solid var(--md-sys-color-outline);
            border-radius: 100px; position: relative; transition: 0.2s; box-sizing: border-box;
        }
        .beta-switch::after { 
            content: ''; position: absolute; top: 50%; left: 6px; transform: translateY(-50%);
            width: 16px; height: 16px; 
            background: var(--md-sys-color-outline); border-radius: 50%; transition: 0.2s cubic-bezier(0.2, 0, 0, 1.3); 
        }
        /* Switch Active State */
        .beta-toggle.active .beta-switch { 
            background: var(--md-sys-color-primary); 
            border-color: var(--md-sys-color-primary); 
        }
        .beta-toggle.active .beta-switch::after { 
            background: var(--md-sys-color-on-primary); 
            width: 24px; height: 24px; left: calc(100% - 28px); 
        }
        
        #group-scene { display: none; margin-top: 10px; border-style:dashed; }
        #group-scene.visible { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity:0; transform:translateY(-10px); } to { opacity:1; transform:translateY(0); } }

        /* Footer */
        .footer { padding: 24px 16px; background: var(--md-sys-color-surface-container); display: flex; flex-direction: column; gap: 12px; margin-top: auto; flex-shrink: 0;}
        
        /* M3 Filled Button */
        .btn-filled { 
            width: 100%; height: 40px; border: none; border-radius: 20px; 
            background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); 
            font-weight: 500; font-size: 14px; letter-spacing: 0.1px;
            cursor: pointer; display: flex; justify-content: center; align-items: center; 
            transition: 0.2s; 
        }
        .btn-filled:hover { background: color-mix(in srgb, var(--md-sys-color-primary), black 8%); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .btn-filled svg { width: 18px; margin-right: 8px; fill: currentColor; }
        
        /* M3 Text Button */
        .btn-text { 
            background: transparent; color: var(--md-sys-color-primary); 
            border: none; height: 40px; border-radius: 20px; 
            cursor: pointer; font-size: 14px; font-weight: 500; transition: 0.2s; 
        }
        .btn-text:hover { background: var(--md-state-primary-hover); }
        
        /* Error State */
        .btn-text.error { color: #ffb4ab; margin-top: 12px; width: 100%; }
        .btn-text.error:hover { background: rgba(255, 180, 171, 0.08); }

        /* Normal Mode List */
        .file-list { border: 1px solid var(--md-sys-color-outline-variant); border-radius: var(--shape-s); overflow: hidden; margin-top:10px; }
        .file-item { padding: 12px; border-bottom: 1px solid var(--md-sys-color-outline-variant); background: var(--md-sys-color-surface-container); font-size: 13px; display:flex; gap:8px; align-items:center; }
        
        /* Outlined Button (Add File) */
        .btn-add-file { 
            position: relative; width: 100%; padding: 10px; 
            border: 1px solid var(--md-sys-color-outline); border-radius: 20px;
            color: var(--md-sys-color-primary); text-align: center; font-size: 14px; font-weight: 500;
            cursor: pointer; display: flex; align-items: center; justify-content: center; margin-bottom: 12px;
            transition: 0.2s; box-sizing: border-box;
        }
        .btn-add-file:hover { background: var(--md-state-primary-hover); border-color: var(--md-sys-color-primary); }
        .btn-add-file input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

        /* Log Box */
        .log-box { 
            font-family: 'Consolas', monospace; font-size: 11px; color: #90A4AE; 
            background: #111; padding: 10px; border-radius: 4px;
            height: 100px; overflow-y: auto; margin-bottom: 10px; display:none;
        }
        .log-line { margin-bottom: 2px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-ok { color: #76FF33; }

        ::-webkit-scrollbar { width: 4px; } 
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #546E7A; border-radius: 2px; }

        #mount-status { font-size: 12px; color: var(--md-sys-color-on-surface-variant); text-align: center; display: none; align-items: center; justify-content: center; gap: 8px; margin-top: 4px; }
        #mount-status.active { color: var(--md-sys-color-primary); }
        .status-badge { padding: 2px 6px; background: var(--md-sys-color-surface-container-high); border-radius: 4px; font-weight: 500; font-size: 10px; letter-spacing: 0.5px; }
    </style>
    <script type="importmap">
        { 
            "imports": { 
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
            } 
        }
    </script>
</head>
<body class="fouc-loading">

    <div id="top-bar">
        <div class="app-title" id="t-app-title">Tanki Model showcase</div>
    </div>
    <div id="toast"><span>Ready</span></div>
    <button id="fab"><svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></button>

    <div id="drawer" class="open">
        <div class="tab-group">
            <div class="tab-btn" onclick="switchMode('assembly')" id="t-tab-assembly">Tank Assembly</div>
            <div class="tab-btn" onclick="switchMode('normal')" id="t-tab-normal">Local File</div>
        </div>

        <!-- Assembly Mode -->
        <div id="panel-assembly" class="drawer-content">
            <div style="height:20px"></div>

            <!-- Hull Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--hull)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 3L3 2H7L8 3H16V5H6V6H10L12 8H15L16 9V11L14 13H2L0 11V8L2 6V3Z" fill="currentColor"/>
                    </svg>
                    <span id="t-hull-title">Hull Configuration</span>
                </div>
                <!-- Controls -->
                <div class="control-col">
                    <!-- Hull Model Select -->
                    <div id="box-hull" class="m3-custom-select-container">
                        <select id="sel-hull-name" class="native-select-hidden"><option>Loading...</option></select>
                    </div>

                    <!-- Hull Skin Select -->
                    <div id="box-hull-skin" class="m3-custom-select-container">
                        <select id="sel-hull-skin" class="native-select-hidden"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Turret Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--turret)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M5 0H7V12H9V0H11V6L14 9V13L11 16V16H9H7H5V16L2 13V9L5 6V0Z" fill="currentColor"/>
                    </svg>
                    <span id="t-turret-title">Turret Configuration</span>
                </div>
                <!-- Controls -->
                <div class="control-col">
                    <!-- Turret Model Select -->
                    <div id="box-turret" class="m3-custom-select-container">
                        <select id="sel-turret-name" class="native-select-hidden"><option>Loading...</option></select>
                    </div>
                    <!-- Turret Skin Select -->
                    <div id="box-turret-skin" class="m3-custom-select-container">
                        <select id="sel-turret-skin" class="native-select-hidden"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Beta Toggle -->
            <div class="beta-toggle" onclick="toggleScene()">
                <div class="beta-label" id="t-beta-label">Show Environment (Beta)</div>
                <div class="beta-switch" id="scene-sw"></div>
            </div>

            <!-- Hidden Scene Card -->
            <div class="m3-card" id="group-scene">
                <div class="card-title" style="color:var(--scene)" id="t-scene-title">Map / Garage</div>
                <div class="slot-display">
                    <div class="slot-text">
                        <h3 id="display-scene" class="t-scene-display">No Environment</h3>
                    </div>
                </div>
                <div id="scene-log" class="log-box"></div>
                <div class="control-col">
                    <div id="box-scene" class="m3-custom-select-container">
                         <select id="sel-scene-var" class="native-select-hidden"><option>Loading...</option></select>
                    </div>
                </div>
                <button class="btn-text error t-remove-env" id="btn-clear-scene">Remove Environment</button>
            </div>

        </div>

        <!-- Normal Mode -->
        <div id="panel-normal" class="drawer-content">
            <div style="margin: 24px 0 16px;">
                <label class="btn-add-file">
                    <svg viewBox="0 0 24 24" style="width:18px;margin-right:8px;fill:currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    <span id="t-import-btn">Import .a3d / .3ds files</span>
                    <input type="file" id="in-normal" multiple>
                </label>
            </div>
            <div class="card-title" id="t-res-title">IMPORTED RESOURCES</div>
            <div id="list-normal" class="file-list"></div>
        </div>

        <div class="footer">
            <div id="mount-status"><span class="status-badge t-mount-status">MOUNT POINT</span> <span id="mount-txt" class="t-mount-none">Not Detected</span></div>
            <button class="btn-filled" id="btn-export">
                <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                <span id="t-export">Export GLB</span>
            </button>
            <button class="btn-text t-clear" id="btn-clear">Clear All Objects</button>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TDSLoader } from 'three/addons/loaders/TDSLoader.js'; 
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'; 

    // Constants
    const ASSETS_INDEX_URL = "https://testanki1.github.io/models/assets.json";
    const ICON_BASE_EQUIP = "https://testanki1.github.io/equipment_icons";
    const ICON_BASE_SKIN = "https://testanki1.github.io/skin_icons";

    // --- I18n System ---
    const userLang = navigator.language.startsWith('zh') ? 'zh' : 'en';
    const RES_BASE = userLang === 'zh' ? "https://res.3dtank.com" : "https://s.eu.tankionline.com";
    
    const CNDict = {
        'default': '默认', 'firebird': '火焰炮', 'freeze': '冰风暴', 'isida': '磁力炮', 'tesla': '特斯拉', 'hammer': '滑膛炮',
        'twins': '离子炮', 'ricochet': '火龙珠', 'smoky': '轰天炮', 'striker': '火箭炮', 'vulcan': '极速炮',
        'thunder': '雷暴炮', 'scorpion': '蝎子', 'railgun': '激光炮', 'magnum': '马格南', 'gauss': '电磁炮', 'shaft': '镭射炮',
        'wasp': '黄蜂轻甲', 'hornet': '蜂王', 'hopper': '霍珀', 'paladin': '圣骑士', 'hunter': '猎人中甲',
        'crusader': '十字军', 'viking': '维京', 'dictator': '独裁者', 'ares': '阿瑞斯', 'titan': '泰坦', 'mammoth': '猛犸象',
        'brutus': '布鲁特斯', 'mechanic': '机械师', 'trickster': '魔术师', 'saboteur': '破坏者', 'booster': '助推器',
        'defender': '守卫者', 'hyperion': '亥伯龙神', 'crisis': '危机', 'supply': '道具', 'ut': '超高', 'pr': '青春',
        'lc': '遗产', 'xt': 'XT', 'dc': '恶魔', 'gt': 'GT（跑车）', 'hd': 'HD（高清）', 'rf': 'RF（复古未来）', 'se': 'SE（秘密）', 'vt': 'VT（老兵）',
        'dk': 'DK（暗黑）', 'sp': 'SP（蒸汽朋克）', 'ic': 'IC（冰）', 'old': '旧'
    };

    const Dict = {
        zh: {
            appTitle: "3D坦克模型展示",
            tabNormal: "本地文件",
            tabAssembly: "坦克组装",
            importBtn: "导入 .a3d / .3ds 文件",
            resTitle: "已导入资源",
            hullTitle: "底盘配置",
            hullSub: "选择底盘以装备",
            turretTitle: "炮塔配置",
            turretSub: "选择炮塔以装备",
            lblModel: "装备",
            lblSkin: "皮肤",
            lblEnv: "环境",
            betaLabel: "显示环境 (Beta)",
            sceneTitle: "地图 / 车库",
            sceneDisplay: "无环境",
            removeEnv: "移除环境",
            mountStatus: "挂载点",
            mountActive: "已锁定",
            mountNone: "未检测",
            export: "导出 GLB",
            clear: "清空场景",
            loading: "加载中..."
        },
        en: {
            appTitle: "Tanki Model Showcase",
            tabNormal: "Local File",
            tabAssembly: "Tank Assembly",
            importBtn: "Import .a3d / .3ds files",
            resTitle: "IMPORTED RESOURCES",
            hullTitle: "Hull Configuration",
            hullSub: "Select a hull to equip",
            turretTitle: "Turret Configuration",
            turretSub: "Select a turret to equip",
            lblModel: "Equipment",
            lblSkin: "Skin",
            lblEnv: "Environment",
            betaLabel: "Show Environment (Beta)",
            sceneTitle: "Map / Garage",
            sceneDisplay: "No Environment",
            removeEnv: "Remove Environment",
            mountStatus: "MOUNT POINT",
            mountActive: "Active",
            mountNone: "Not Detected",
            export: "Export GLB",
            clear: "Clear All Objects",
            loading: "Loading..."
        }
    };
    const T = Dict[userLang];

    // Apply Static Translations
    function applyI18n() {
        document.getElementById('t-app-title').innerText = T.appTitle;
        document.getElementById('t-tab-normal').innerText = T.tabNormal;
        document.getElementById('t-tab-assembly').innerText = T.tabAssembly;
        document.getElementById('t-import-btn').innerText = T.importBtn;
        document.getElementById('t-res-title').innerText = T.resTitle;
        document.getElementById('t-hull-title').innerText = T.hullTitle;
        document.getElementById('t-turret-title').innerText = T.turretTitle;
        document.getElementById('t-beta-label').innerText = T.betaLabel;
        document.getElementById('t-scene-title').innerText = T.sceneTitle;
        document.getElementById('t-export').innerText = T.export;
        
        document.querySelectorAll('.t-lbl-model').forEach(el => el.innerText = T.lblModel);
        document.querySelectorAll('.t-lbl-skin').forEach(el => el.innerText = T.lblSkin);
        document.querySelectorAll('.t-lbl-env').forEach(el => el.innerText = T.lblEnv);
        document.querySelectorAll('.t-hull-sub').forEach(el => el.innerText = T.hullSub);
        document.querySelectorAll('.t-turret-sub').forEach(el => el.innerText = T.turretSub);
        document.querySelectorAll('.t-scene-display').forEach(el => el.innerText = T.sceneDisplay);
        document.querySelectorAll('.t-remove-env').forEach(el => el.innerText = T.removeEnv);
        document.querySelectorAll('.t-mount-status').forEach(el => el.innerText = T.mountStatus);
        document.querySelectorAll('.t-mount-none').forEach(el => el.innerText = T.mountNone);
        document.querySelectorAll('.t-clear').forEach(el => el.innerText = T.clear);
    }

    // Dynamic Data Translation
    const EN_ACRO = new Set(['XT', 'LC', 'DC', 'GT', 'HD', 'RF', 'SE', 'VT', 'DK', 'SP', 'IC', 'UT', 'PR', 'UFO']);
    const EN_TERMS = {
        '万圣节': 'Halloween', '新年': 'New Year', '生日': 'Birthday', 'UFO 日': 'UFO Day',
        '雪人': 'Snowman', '番茄炮': 'Tomato', '螯': 'Claw', '蜘蛛': 'Spider'
    };

    function formatName(name) {
        let text = name.replace(/_/g, ' ');
        if(userLang === 'zh') {
            return text.split(' ').map(part => {
                const lc = part.toLowerCase();
                return CNDict[lc] || part;
            }).join(' ');
        } else {
            Object.entries(EN_TERMS).forEach(([zh, en]) => {
                text = text.replace(new RegExp(zh, 'g'), en);
            });
            return text.split(' ').map(s => {
                const upper = s.toUpperCase();
                if(EN_ACRO.has(upper)) return upper;
                return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
            }).join(' ');
        }
    }

    function translateDataKey(key) {
        return formatName(key);
    }

    // --- Icon Loader Class ---
    const IconLoader = {
        cache: new Map(),
        
        // Returns SVG String (for inlining, allows recolor)
        async getEquipmentIcon(internalName) {
            let filename = internalName;
            const lower = internalName.toLowerCase();
            if (lower === 'b0-nk') filename = 'bonk';
            
            const url = `${ICON_BASE_EQUIP}/${filename}.svg`;
            
            try {
                if (this.cache.has(url)) return this.cache.get(url);
                
                const resp = await fetch(url);
                if (!resp.ok) throw "Icon 404";
                let text = await resp.text();
                
                // Simple cleanup
                text = text.replace(/<\?xml.*?\?>/g, '').replace(/<!DOCTYPE.*?>/g, '');
                
                // Ensure currentColor is used for fills if they aren't 'none' or 'currentColor'
                text = text.replace(/fill="(?!(none|currentColor))[^"]*"/gi, 'fill="currentColor"');
                
                if (!text.includes('fill="currentColor"') && !text.includes('fill="none"')) {
                     text = text.replace('<svg', '<svg fill="currentColor"');
                }
                
                this.cache.set(url, text);
                return text;
            } catch (e) {
                return null;
            }
        },

        // Returns URL String (for <img src>, protects original color)
        getSkinIconUrl(skinId) {
            if(!skinId) return null;
            const lower = skinId.toLowerCase();
            
            // Special Mappings (Equipment icons reused as skins)
            // Handle both English and Chinese keys
            if (lower === 'claw' || lower === '螯' || lower === 'spider' || lower === '蜘蛛') 
                return `${ICON_BASE_EQUIP}/bonk.svg`;
            
            // "Tomato" or "Tomato Gun" or "番茄" or "番茄炮"
            if (lower.includes('tomato') || lower.includes('番茄')) 
                return `${ICON_BASE_EQUIP}/magnum.svg`;
                
            if (lower === 'snowman' || lower === '雪人') 
                return `${ICON_BASE_EQUIP}/freeze.svg`;
            
            // Standard Skin Mappings
            if (lower === 'default' || lower === '默认') 
                return `${ICON_BASE_SKIN}/standard.svg`;
            
            // "Old Demon" -> DC (悪魔)
            const isDc = lower.includes('dc') || lower.includes('恶魔');
            const isOld = lower.includes('old') || lower.includes('旧');
            if (isDc && isOld) return `${ICON_BASE_SKIN}/DC.svg`;

            // Filename generation
            let filename = "";
            if (lower === 'ic') filename = "ICE.svg";
            else if (lower === 'xt_hd') filename = "XT_HD.svg";
            else filename = `${skinId.toUpperCase()}.svg`; 
            
            return `${ICON_BASE_SKIN}/${filename}`;
        }
    };

    // State
    let currentMode = 'assembly'; // Default mode
    const slots = { hull: null, turret: null, scene: null };
    const pools = { hull: [], turret: [] };
    let assetsData = null; // Store fetched index
    
    // Scene Lib
    const sceneLib = { tex: new Map(), meshes: [] };
    const logBox = document.getElementById('scene-log');

    let normalMeshes = [], normalTextures = [];

    // Helpers
    const mountHelper = new THREE.Mesh(new THREE.SphereGeometry(3,8,8), new THREE.MeshBasicMaterial({color:0x76FF33}));
    mountHelper.visible = false;
    let mountPos = null;

    // Scene
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x001926);
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 1, 1e6); camera.position.set(150,150,150);
    const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true, logarithmicDepthBuffer: true}); 
    renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio); 
    renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true;
    
    const root = new THREE.Group(); root.rotation.set(-Math.PI/2, 0, 0); scene.add(root);
    const groupNormal = new THREE.Group();
    const groupAssembly = new THREE.Group();
    groupNormal.visible = false;
    groupAssembly.visible = true; // Default
    root.add(groupNormal);
    root.add(groupAssembly);
    
    root.add(mountHelper);

    const lg = new THREE.Group(); scene.add(lg);
    lg.add(new THREE.AmbientLight(0xffffff, 1.2));
    const sun = new THREE.DirectionalLight(0xffeebb, 2.5); sun.position.set(50,80,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); lg.add(sun);
    lg.add(new THREE.DirectionalLight(0xcceeff, 1.0));

    window.onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)};
    function animate(){requestAnimationFrame(animate);lg.quaternion.copy(camera.quaternion);controls.update();renderer.render(scene,camera)}
    animate();

    // UI Helpers
    const drawer=document.getElementById('drawer'), fab=document.getElementById('fab');
    let open=true; fab.onclick=()=>{open=!open;if(open)drawer.style.display='flex';else drawer.style.display='none'};
    function msg(t){const el=document.getElementById('toast');el.innerText=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),2000)}
    
    function log(msg) {
        const div = document.createElement('div');
        div.className = `log-line log-ok`;
        div.innerText = msg;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
    }

    // Initialize
    applyI18n();
    document.body.classList.remove('fouc-loading');

    (async function init() {
        document.getElementById('t-tab-assembly').classList.add('active');
        document.getElementById('panel-assembly').classList.add('active');
        document.getElementById('mount-status').style.display = 'flex';
        
        try {
            msg(T.loading);
            const resp = await fetch(ASSETS_INDEX_URL);
            if(!resp.ok) throw "Fetch failed";
            assetsData = await resp.json();
            
            // Build UI
            await populateUI();
            
            // Auto-load if in assembly mode (defaults to first item usually)
            if(currentMode==='assembly') {
                // 加载底盘
                if(!slots.hull && document.getElementById('sel-hull-name').value) triggerLoad('hull');
                // 加载炮塔 (新增这行)
                if(!slots.turret && document.getElementById('sel-turret-name').value) triggerLoad('turret');
            }
            msg("Ready");
        } catch(e) {
            console.error(e);
            msg("Failed to load index");
        }
    })();

    // Beta Toggle Logic
    window.toggleScene = function() {
        const toggle = document.querySelector('.beta-toggle');
        const box = document.getElementById('group-scene');
        const active = toggle.classList.toggle('active');
        if(active) {
            box.classList.add('visible');
            if(!slots.scene && document.getElementById('sel-scene-var').value) triggerSceneLoad();
        } else {
            box.classList.remove('visible');
        }
    }

    // --- M3 Custom Select Logic ---
    async function renderCustomSelect(nativeSelectId, type, items) {
        // Items: [{ value, label }]
        const nativeSel = document.getElementById(nativeSelectId);
        const container = nativeSel.parentElement;
        const oldCustom = container.querySelector('.m3-custom-select');
        if(oldCustom) oldCustom.remove();
        
        // Setup Native Options (Hidden source of truth)
        nativeSel.innerHTML = "";
        items.forEach(item => nativeSel.add(new Option(item.label, item.value)));

        // Create DOM
        const wrapper = document.createElement('div');
        wrapper.className = 'm3-custom-select';
        
        // Determine label text
        let labelTxt = "";
        if(type === 'model') labelTxt = T.lblModel;
        else if(type === 'skin') labelTxt = T.lblSkin;
        else if(type === 'env') labelTxt = T.lblEnv;

        // Determine Initial Icon (first item)
        const initialVal = items[0]?.value;
        const initialLabel = items[0]?.label || "Select...";
        
        wrapper.innerHTML = `
            <span class="select-label">${labelTxt}</span>
            <div class="spinner"></div>
            <div class="select-trigger">
                <div class="select-icon-box"></div>
                <span class="select-text">${initialLabel}</span>
                <div class="select-arrow">
                    <svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z" fill="currentColor"/></svg>
                </div>
            </div>
            <div class="m3-options-panel"></div>
        `;
        
        const trigger = wrapper.querySelector('.select-trigger');
        const iconBox = wrapper.querySelector('.select-icon-box');
        const textBox = wrapper.querySelector('.select-text');
        const panel = wrapper.querySelector('.m3-options-panel');
        
        // Helper to update displayed selection
        const updateDisplay = async (val, txt) => {
            textBox.innerText = txt;
            iconBox.innerHTML = ""; // Clear current
            
            if (type === 'model') {
                const svg = await IconLoader.getEquipmentIcon(val);
                if(svg) iconBox.innerHTML = svg;
            } else if (type === 'skin') {
                const url = IconLoader.getSkinIconUrl(val);
                if(url) iconBox.innerHTML = `<img src="${url}" draggable="false" alt="">`;
            }
        };

        // Populate Dropdown
        for (const item of items) {
            const row = document.createElement('div');
            row.className = 'm3-option-row';
            if(item.value === initialVal) row.classList.add('selected');
            
            // Icon holder
            const iHolder = document.createElement('div'); iHolder.className = 'opt-icon';
            const txt = document.createElement('div'); txt.className = 'opt-text'; txt.innerText = item.label;
            
            row.appendChild(iHolder); row.appendChild(txt);
            
            row.onclick = (e) => {
                e.stopPropagation();
                // Update Native Select
                nativeSel.value = item.value;
                // Update Custom UI
                panel.querySelectorAll('.m3-option-row').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');
                updateDisplay(item.value, item.label);
                
                // Close menu
                panel.classList.remove('show');
                wrapper.classList.remove('active');
                
                // Trigger Native Change Event
                nativeSel.dispatchEvent(new Event('change'));
            };
            
            panel.appendChild(row);
            
            // Load Icon Async (Branching Logic)
            (async () => {
                if(type === 'model') {
                    const svg = await IconLoader.getEquipmentIcon(item.value);
                    if(svg) iHolder.innerHTML = svg;
                } else if(type === 'skin') {
                    const url = IconLoader.getSkinIconUrl(item.value);
                    if(url) iHolder.innerHTML = `<img src="${url}" loading="lazy" alt="">`;
                }
            })();
        }

        // Trigger Click
        wrapper.onclick = (e) => {
            // Close other dropdowns
            document.querySelectorAll('.m3-options-panel.show').forEach(p => {
                if(p !== panel) { p.classList.remove('show'); p.parentElement.classList.remove('active'); }
            });
            
            const isOpen = panel.classList.contains('show');
            if(isOpen) {
                panel.classList.remove('show');
                wrapper.classList.remove('active');
            } else {
                panel.classList.add('show');
                wrapper.classList.add('active');
            }
        };

        // Initialize Display
        if(items.length > 0) updateDisplay(initialVal, initialLabel);

        // Inject
        container.insertBefore(wrapper, nativeSel);
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if(!e.target.closest('.m3-custom-select')) {
            document.querySelectorAll('.m3-options-panel.show').forEach(p => {
                p.classList.remove('show');
                p.parentElement.classList.remove('active');
            });
        }
    });


    async function populateUI() {
        if(!assetsData) return;
        
        // Hulls
        const hullKeys = Object.keys(assetsData.hulls || {});
        const hullItems = hullKeys.map(k => ({ value: k, label: formatName(k) }));
        await renderCustomSelect('sel-hull-name', 'model', hullItems);
        
        // Wire events
        const selHull = document.getElementById('sel-hull-name');
        selHull.onchange = () => {
            updateSkinSelect('hull', selHull.value);
            if(currentMode==='assembly') triggerLoad('hull');
        };

        // Turrets
        const turretKeys = Object.keys(assetsData.turrets || {});
        const turretItems = turretKeys.map(k => ({ value: k, label: formatName(k) }));
        await renderCustomSelect('sel-turret-name', 'model', turretItems);

        const selTurret = document.getElementById('sel-turret-name');
        selTurret.onchange = () => {
            updateSkinSelect('turret', selTurret.value);
            if(currentMode==='assembly') triggerLoad('turret');
        };

        // Scenes
        const selScene = document.getElementById('sel-scene-var');
        const garageData = assetsData.festivals?.garage || {};
        const sceneItems = Object.keys(garageData).map(k => ({ value: k, label: translateDataKey(k) }));
        
        await renderCustomSelect('sel-scene-var', 'env', sceneItems);
        selScene.onchange = () => triggerSceneLoad();

        // Initialize Skins
        if(hullItems.length) updateSkinSelect('hull', hullItems[0].value);
        if(turretItems.length) updateSkinSelect('turret', turretItems[0].value);
    }

    async function updateSkinSelect(type, name) {
        const skins = assetsData[`${type}s`][name] || {};
        const skinItems = Object.keys(skins).map(k => ({ value: k, label: formatName(k) }));
        
        // Sort: default first
        skinItems.sort((a,b) => (a.value==='default') ? -1 : 1);
        
        await renderCustomSelect(`sel-${type}-skin`, 'skin', skinItems);
        
        const selSkin = document.getElementById(`sel-${type}-skin`);
        selSkin.onchange = () => { if(currentMode==='assembly') triggerLoad(type); };
    }

    // --- Loading Logic ---
    async function fetchMeta(path) {
        const url = `${RES_BASE}/${path}/meta.info`;
        const res = await fetch(url);
        return await res.json();
    }

    let loadingState = { hull: false, turret: false, scene: false };

    async function triggerLoad(type) {
        if(loadingState[type]) return; 
        
        const name = document.getElementById(`sel-${type}-name`).value;
        const skin = document.getElementById(`sel-${type}-skin`).value;
        if(!name || !skin || name==='Loading...' || skin==='-') return;

        const path = assetsData[`${type}s`][name][skin];
        if(!path) return;
        
        const box = document.getElementById(`box-${type}`);
        // Add loading class to custom wrapper
        const wrapper = box.querySelector('.m3-custom-select');
        if(wrapper) wrapper.classList.add('loading');
        
        loadingState[type] = true;
        
        await loadRemoteAsset(path, type);
        
        if(wrapper) wrapper.classList.remove('loading');
        loadingState[type] = false;
    }

    async function triggerSceneLoad() {
        if(loadingState.scene) return;
        const variant = document.getElementById('sel-scene-var').value;
        const path = assetsData.festivals.garage[variant];
        if(!path) return;
        
        const box = document.getElementById('box-scene');
        const wrapper = box.querySelector('.m3-custom-select');
        if(wrapper) wrapper.classList.add('loading');
        loadingState.scene = true;
        
        await loadRemoteScene(path, variant);
        
        if(wrapper) wrapper.classList.remove('loading');
        loadingState.scene = false;
        
        document.getElementById(`display-scene`).innerText = `Garage: ${translateDataKey(variant)}`;
    }

    async function loadRemoteAsset(pathStr, type) {
        try {
            msg(`${T.loading} ${type}...`);
            const meta = await fetchMeta(pathStr);
            
            let modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.a3d'));
            if(!modelEntry) modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.3ds'));
            
            if(!modelEntry) throw "Model file not found";

            // Find all textures
            const imgEntries = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i) && !f.name.endsWith('.ktx'));
            
            const modelUrl = `${RES_BASE}/${pathStr}/${modelEntry.name}`;
            
            let group;
            if(modelEntry.name.endsWith('.a3d')) {
                const buf = await (await fetch(modelUrl)).arrayBuffer();
                group = parseA3D(buf, modelEntry.name);
            } else {
                const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${pathStr}/`);
                group = await loader.loadAsync(modelUrl);
                group.traverse(o => { 
                    if(o.isMesh) { 
                        o.material = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.4, side:2}); 
                        o.userData.originalName = o.name; 
                    }
                });
            }

            pools[type] = [];
            if(imgEntries.length > 0) {
                const texPromises = imgEntries.map(async entry => {
                    const texUrl = `${RES_BASE}/${pathStr}/${entry.name}`;
                    const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                    setupTex(tex); tex.name = entry.name;
                    return { name: entry.name, tex: tex };
                });
                pools[type] = await Promise.all(texPromises);
                applyTexturesFromPool(group, pools[type]);
            }

            equipAssembly(group, modelEntry.name, type);
            msg(`${type.toUpperCase()} Ready`);

        } catch(e) {
            console.error(e);
            msg(`Error loading ${type}`);
        }
    }

    function applyTexturesFromPool(group, pool) {
        if (!pool || pool.length === 0) return;
        
        const findTex = (k) => pool.find(p => p.name.toLowerCase().includes(k))?.tex;
        const texTracks = findTex('track') || findTex('chain');
        const texWheels = findTex('wheel'); 
        const texLightmap = findTex('lightmap') || findTex('map') || pool[0].tex;

        group.traverse(m => {
            if (!m.isMesh) return;
            const name = (m.userData.originalName || m.name).toLowerCase();
            let target = texLightmap;
            
            if (name.includes('track') || name.includes('chain')) target = texTracks || target;
            else if (name.includes('wheel')) target = texWheels || target;
            
            if (target) setMat(m, target);
        });
    }

    async function loadRemoteScene(path, variant) {
        if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
        sceneLib.meshes = []; sceneLib.tex.clear();
        logBox.style.display = 'block'; logBox.innerHTML='';
        
        try {
            msg(T.loading);
            const meta = await fetchMeta(path);
            
            const models = meta.filter(f => f.name.match(/\.(a3d|3ds)$/i));
            const images = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i));

            const texProm = images.map(async f => {
                const texUrl = `${RES_BASE}/${path}/${f.name}`;
                const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                tex.name = f.name; setupTex(tex);
                return { n: f.name, t: tex };
            });
            const loadedTex = await Promise.all(texProm);
            loadedTex.forEach(o => sceneLib.tex.set(o.n, o.t));

            const combinedGroup = new THREE.Group();
            
            for(let f of models) {
                const mUrl = `${RES_BASE}/${path}/${f.name}`;
                let grp;
                if(f.name.endsWith('.a3d')) {
                    const buf = await (await fetch(mUrl)).arrayBuffer();
                    grp = parseA3D(buf, f.name);
                } else {
                    const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${path}/`);
                    grp = await loader.loadAsync(mUrl);
                }
                
                grp.traverse(o => { 
                    if (o.isMesh) { 
                        if (o.parent) o.userData.parentName = o.parent.name; 
                        sceneLib.meshes.push(o); 
                    } 
                });
                combinedGroup.add(grp);
            }

            slots.scene = combinedGroup; 
            groupAssembly.add(combinedGroup);
            
            runSceneInjector();
            fitCamera();
            msg("Environment Loaded");

        } catch(e) {
            console.error(e);
            msg("Scene Load Failed");
        }
    }

    // --- Standard Functions ---

    window.switchMode = function(mode) {
        if(currentMode === mode) return;
        currentMode = mode;
        
        document.querySelectorAll('.tab-btn').forEach((el,i) => {
            const modes = ['assembly','normal'];
            el.classList.toggle('active', modes[i] === mode);
        });
        ['normal','assembly'].forEach(m => document.getElementById('panel-'+m).classList.toggle('active', m===mode));
        
        groupNormal.visible = (mode === 'normal');
        groupAssembly.visible = (mode === 'assembly');
        
        if (mode === 'assembly') {
             document.getElementById('mount-status').style.display = 'flex';
             if(mountPos) mountHelper.visible = true;

             if(!slots.hull && document.getElementById('sel-hull-name').value) triggerLoad('hull');
             if(!slots.turret && document.getElementById('sel-turret-name').value) triggerLoad('turret');
        } else {
             document.getElementById('mount-status').style.display = 'none';
             mountHelper.visible = false;
        }
    }

    const loadingManager = new THREE.LoadingManager();

    document.getElementById('btn-clear').onclick = clearScene;

    document.getElementById('btn-export').onclick = () => {
        const toExport = currentMode === 'normal' ? groupNormal : groupAssembly;
        if(toExport.children.length === 0) { msg("Empty Scene"); return; }
        
        const exporter = new GLTFExporter();
        const wasVisible = mountHelper.visible; mountHelper.visible = false;
        
        exporter.parse(root, (result) => {
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const link = document.createElement('a'); 
                link.href = URL.createObjectURL(blob); 
                link.download = 'tanki_model.glb'; 
                link.click();
                msg(T.export + " OK"); 
                mountHelper.visible = wasVisible;
            }, (err) => { 
                console.error(err); 
                msg("Export Failed"); 
                mountHelper.visible = wasVisible;
            }, { binary: true, onlyVisible: true }
        );
    };

    document.getElementById('in-normal').onchange = async e => {
        const arr = Array.from(e.target.files);
        const models = arr.filter(f=>f.name.match(/\.(a3d|3ds)$/i));
        const images = arr.filter(f=>f.type.startsWith('image/'));
        for(let f of models) {
            try {
                const grp = await loadModelFile(f); 
                groupNormal.add(grp);
                grp.traverse(o=>{ if(o.isMesh) normalMeshes.push(o); });
                addUI('list-normal', f.name);
            } catch(e){}
        }
        for(let f of images) {
            const url = URL.createObjectURL(f);
            new THREE.TextureLoader().load(url, t => {
                setupTex(t); t.name = f.name;
                normalTextures.push(t);
                applyNormalTexture(t);
                addUI('list-normal', f.name);
            });
        }
        fitCamera(); e.target.value='';
    };

    function runSceneInjector() {
        let count = 0; log(">>> Injecting Textures...");
        sceneLib.meshes.forEach(mesh => {
            const candidates = [];
            if (mesh.material && mesh.material.name) candidates.push(mesh.material.name);
            if (mesh.name) candidates.push(mesh.name);
            if (mesh.userData.parentName) candidates.push(mesh.userData.parentName);
            let bestTex = null;
            for (const [texName, texObj] of sceneLib.tex) {
                const cleanTexName = texName.toLowerCase().split('.')[0];
                for (const cand of candidates) {
                    const cleanCand = cand.toLowerCase();
                    if (cleanCand.includes(cleanTexName)) { bestTex = texObj; break; }
                    if (cleanTexName.includes(cleanCand) && cleanCand.length > 3) { bestTex = texObj; break; }
                }
                if (bestTex) break;
            }
            if (bestTex) {
                mesh.material = new THREE.MeshStandardMaterial({
                    map: bestTex, emissiveMap: bestTex, emissive: new THREE.Color(0x888888), 
                    color: 0xffffff, side: THREE.DoubleSide, transparent: true, alphaTest: 0.5 
                });
                mesh.material.needsUpdate = true; log(`✔ [${mesh.name}] -> ${bestTex.name}`); count++;
            }
        });
        if(count > 0) msg(`Matched ${count} materials`); else log("⚠ No matches found");
    }

    document.getElementById('btn-clear-scene').onclick = () => {
         if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
         sceneLib.tex.forEach(t => t.dispose()); sceneLib.tex.clear();
         sceneLib.meshes = [];
         logBox.innerHTML = ''; logBox.style.display = 'none';
         document.getElementById('display-scene').innerText = T.sceneDisplay;
         msg(T.removeEnv);
    };

    async function loadModelFile(file) {
        const ext = file.name.split('.').pop().toLowerCase();
        if (ext === 'a3d') return parseA3D(await file.arrayBuffer(), file.name);
        else if (ext === '3ds') {
            const loader = new TDSLoader(); loader.setResourcePath('');
            const g = await loader.loadAsync(URL.createObjectURL(file));
            g.traverse(o => { if(o.isMesh) { o.material=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.4,side:2}); o.userData.originalName=o.name; }});
            return g;
        }
    }

    function equipAssembly(grp, fname, type) {
        if(slots[type]) { groupAssembly.remove(slots[type].group); dispose(slots[type].group); }
        slots[type] = { group: grp, name: fname }; groupAssembly.add(grp);
        if(type==='hull') { scanMount(grp); snapTurret(); } else { snapTurret(); }
        fitCamera();
    }

    function scanMount(grp) {
        let found = false; grp.updateMatrixWorld(true);
        grp.traverse(o => {
            if(found) return;
            if(o.name && o.name.toLowerCase().includes("mount")) {
                const worldPos = new THREE.Vector3(); o.getWorldPosition(worldPos);
                mountPos = root.worldToLocal(worldPos.clone()); 
                updateMount(mountPos); 
                found = true;
            }
        });
        if(!found) updateMount(null);
    }
    function snapTurret() {
        if(slots.turret) {
            if(slots.hull && mountPos) slots.turret.group.position.copy(mountPos);
            else slots.turret.group.position.set(0,0,0);
        }
    }
    
    function applyNormalTexture(tex) {
        const base = tex.name.toLowerCase().split('.')[0];
        normalMeshes.forEach(m => {
            const part = (m.userData.originalName||m.name).toLowerCase();
            let match = false;
            if(part.includes(base)) match=true;
            else if(base.includes('track') && (part.includes('track')||part.includes('chain'))) match=true;
            else if(base.includes('wheel') && part.includes('wheel')) match=true;
            else if((base.includes('lightmap')||base.includes('map')) && !part.includes('track') && !part.includes('wheel')) match=true;
            if(match) setMat(m, tex);
        });
    }

    function addUI(id, text) {
        const div = document.createElement('div'); div.className = 'file-item';
        div.innerHTML = `<svg viewBox="0 0 24 24" style="width:16px;fill:#90A4AE"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg><span style="margin-left:8px">${text}</span>`;
        document.getElementById(id).appendChild(div);
    }
    function updateMount(pos) {
        const el=document.getElementById('mount-status'), txt=document.getElementById('mount-txt');
        if(pos){
            mountHelper.position.copy(pos); 
            if(currentMode==='assembly') mountHelper.visible=true; 
            el.classList.add('active'); txt.innerText=T.mountActive;
        }
        else{
            mountHelper.visible=false; 
            el.classList.remove('active'); txt.innerText=T.mountNone;
        }
    }
    function clearScene() {
        if(currentMode === 'normal') {
            while(groupNormal.children.length > 0){
                const c = groupNormal.children[0];
                dispose(c); groupNormal.remove(c);
            }
            normalMeshes = []; normalTextures.forEach(t=>t.dispose()); normalTextures = [];
            document.getElementById('list-normal').innerHTML="";
        } else {
            if(slots.hull) { groupAssembly.remove(slots.hull.group); dispose(slots.hull.group); }
            if(slots.turret) { groupAssembly.remove(slots.turret.group); dispose(slots.turret.group); }
            if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); }
            slots.hull=null; slots.turret=null; slots.scene=null; pools.hull=[]; pools.turret=[];
            
            // Re-select first items if available to reset select visuals
            // Or just leave them as is but empty scene.
            logBox.style.display='none';
            updateMount(null);
        }
        
        sceneLib.tex.clear(); sceneLib.meshes=[];
        msg(T.clear);
    }
    function setupTex(t) { t.colorSpace=THREE.SRGBColorSpace; t.wrapS=t.wrapT=THREE.RepeatWrapping; t.anisotropy=renderer.capabilities.getMaxAnisotropy(); }
    function setMat(m, t) { m.material.map=t; m.material.emissiveMap=t; m.material.emissive=new THREE.Color(0xffffff); m.material.emissiveIntensity=0.5; m.material.needsUpdate=true; }
    function dispose(g){if(!g)return; g.traverse(o=>{if(o.isMesh){o.geometry.dispose();if(o.material)o.material.dispose()}})}
    function fitCamera(){const b=new THREE.Box3().setFromObject(root);if(b.isEmpty())return;const c=b.getCenter(new THREE.Vector3()),s=b.getSize(new THREE.Vector3()).length();controls.target.copy(c);camera.position.set(c.x+s,c.y+s*0.5,c.y+s);camera.lookAt(c);controls.update()}

    class BinR { constructor(b){this.v=new DataView(b);this.o=0;this.d=new TextDecoder()} sk(n){this.o+=n} pad(l){return(((l+3)>>2)*4)-l} u32(){const v=this.v.getUint32(this.o,1);this.o+=4;return v} i32(){const v=this.v.getInt32(this.o,1);this.o+=4;return v} u16(){const v=this.v.getUint16(this.o,1);this.o+=2;return v} f32(){const v=this.v.getFloat32(this.o,1);this.o+=4;return v} str(){const l=this.u32();const s=this.d.decode(new Uint8Array(this.v.buffer,this.v.byteOffset+this.o,l));this.o+=l+this.pad(l);return s} str0(){let b=[];while(this.o<this.v.byteLength){const c=this.v.getUint8(this.o++);if(c===0)break;b.push(c)}return this.d.decode(new Uint8Array(b))} }
    function parseA3D(buf, n) { const r = new BinR(buf); if(r.v.getUint8(0)!==65) throw "Err"; r.sk(4); const v=r.u16(); r.sk(2); if(v===3) return pV3(r, n); else if(v===2) return pV2(r, n); }
    function readC(r){r.u32();r.u32();return r.u32()}
    function pV3(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str();r.sk(12);r.str()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:r.str()};r.sk(28);m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const ic=r.u32(),x=new Uint16Array(ic);for(let k=0;k<ic;k++)x[k]=r.u16();r.sk((((ic*2+3)>>2)*4)-(ic*2));m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:r.str(),p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const o={mi:r.u32(),ti:r.u32()},cc=r.u32();for(let k=0;k<cc;k++)r.sk(4);od.push(o)} return build(md,{t:td,p:tp},od,n); }
    function pV2(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str0();r.sk(12);r.str0()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:"M"+i};m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const fc=r.u32(),x=new Uint16Array(fc*3);for(let k=0;k<fc*3;k++)x[k]=r.u16();for(let k=0;k<fc;k++)r.sk(4);r.sk(2);m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:"",p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()-1); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const s=r.str0(),mi=r.u32(),ti=r.u32(); if(td[ti])td[ti].n=s; od.push({mi,ti})} return build(md,{t:td,p:tp},od,n); }
    function build(gd,td,od,fname){const mat=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.3,metalness:0.2,side:2});const geos=gd.map(d=>{const g=new THREE.BufferGeometry();g.userData={n:d.n};d.vb.forEach(v=>{if(v.t===1)g.setAttribute('position',new THREE.BufferAttribute(v.d,3));if(v.t===3)g.setAttribute('normal',new THREE.BufferAttribute(v.d,3));if(v.t===2){for(let i=1;i<v.d.length;i+=2)v.d[i]=1.0-v.d[i];g.setAttribute('uv',new THREE.BufferAttribute(v.d,2))}});let i=[],o=0;d.sm.forEach(s=>{for(let k=0;k<s.x.length;k++)i.push(s.x[k]);g.addGroup(o,s.x.length,0);o+=s.x.length});g.setIndex(i);return g});const grp=new THREE.Group();const nds=td.t.map(t=>{const o=new THREE.Object3D();o.position.set(...t.p);o.quaternion.set(...t.q);o.scale.set(t.s[0]||1,t.s[1]||1,t.s[2]||1);o.name=t.n;return o});td.p.forEach((pid,i)=>{if(pid>=0)nds[pid].add(nds[i]);else grp.add(nds[i])});od.forEach(o=>{if(!geos[o.mi]||!nds[o.ti])return;const nm=nds[o.ti].name||geos[o.mi].userData.n;const m=new THREE.Mesh(geos[o.mi],mat.clone());if(nm.toLowerCase().match(/box|bound|col|shape/))m.visible=false;m.userData.originalName=nm;nds[o.ti].add(m)});return grp}
</script>
</body>
</html>
