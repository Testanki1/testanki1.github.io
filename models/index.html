<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanki Model Showcase</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        /* Prevent FOUT (Flash of Un-translated Text) */
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+1p&display=swap');
        body.fouc-loading { opacity: 0; pointer-events: none; }
        body { transition: opacity 0.3s ease-in; opacity: 1; }

        /* Theme Variables - Neon Green & Deep Blue */
        :root {
            --md-sys-color-background: #001926;
            --md-sys-color-surface: #001E2E;
            --md-sys-color-surface-container: #002b40;
            --md-sys-color-surface-variant: #004d66;
            --md-sys-color-primary: #76FF33;
            --md-sys-color-on-primary: #001926;
            --md-sys-color-primary-container: #004D1A;
            --md-sys-color-on-primary-container: #76FF33;
            --md-sys-color-secondary: #4DD0E1;
            --md-sys-color-outline: #546E7A;
            --md-sys-color-outline-variant: #263238;
            
            --radius-l: 28px;
            --radius-m: 16px;
            --radius-s: 8px;
            
            --hull: #80cbc4; 
            --turret: #ffcc80; 
            --scene: #ffab91; 
        }

        body { 
            margin: 0; overflow: hidden; font-family: 'Rubik', 'M PLUS 1p'; 
            background: var(--md-sys-color-background); color: #E0F2F1; 
            touch-action: none; 
        }
        
        #top-bar { position: absolute; top: 0; left: 0; right: 0; padding: 24px; background: linear-gradient(to bottom, rgba(0,25,38,0.9), transparent); pointer-events: none; z-index: 10; display:flex; flex-direction:column; gap:4px; }
        .app-title { font-weight: 500; font-size: 22px; color: #E0F2F1; letter-spacing: -0.5px; }
        .app-subtitle { font-size: 12px; color: #B0BEC5; opacity: 0.8; }

        #toast { position: absolute; top: 24px; left: 50%; transform: translateX(-50%) translateY(-20px); background: #263238; padding: 14px 24px; border-radius: 50px; opacity: 0; transition: 0.4s cubic-bezier(0.2,0,0,1); pointer-events: none; z-index: 200; box-shadow: 0 4px 8px rgba(0,0,0,0.3); font-size: 14px; color: #ECEFF1; display:flex; align-items:center; gap:8px; border: 1px solid var(--md-sys-color-outline-variant); }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        #fab { position: absolute; bottom: 32px; right: 32px; width: 64px; height: 64px; border-radius: 20px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; transition: 0.3s cubic-bezier(0.2,0,0,1); }
        #fab:hover { transform: scale(1.05); box-shadow: 0 6px 16px rgba(0,0,0,0.5); filter: brightness(1.1); }
        #fab svg { width: 28px; fill: currentColor; }

        /* M3 Drawer */
        #drawer { 
            position: absolute; top: 0; right: 0; bottom: 0; width: 360px; max-width: 95vw; 
            background: var(--md-sys-color-surface-container); 
            border-top-left-radius: var(--radius-l); border-bottom-left-radius: var(--radius-l);
            display: none; z-index: 90; 
            flex-direction: column; box-shadow: -8px 0 24px rgba(0,0,0,0.3);
            border-left: 1px solid rgba(118, 255, 51, 0.1);
        }
        #drawer.open { display: flex; }
        
        /* M3 Tabs */
        .tab-group { display: flex; padding: 16px 16px 8px; gap: 8px; }
        .tab-btn { flex: 1; padding: 10px; text-align: center; font-size: 14px; font-weight: 500; cursor: pointer; color: #90A4AE; border-radius: 50px; transition: 0.2s; border: 1px solid transparent; }
        .tab-btn.active { background: rgba(118, 255, 51, 0.15); color: var(--md-sys-color-primary); font-weight: 600; border-color: rgba(118, 255, 51, 0.3); }
        .tab-btn:hover:not(.active) { background: rgba(255,255,255,0.05); }
        
        .drawer-content { flex: 1; overflow-y: auto; padding: 0 20px 20px; display: none; }
        .drawer-content.active { display: block; }

        /* M3 Cards */
        .m3-card { 
            background: rgba(0, 0, 0, 0.2); border-radius: var(--radius-m); padding: 16px; 
            margin-bottom: 16px; border: 1px solid rgba(255,255,255,0.05); transition: 0.2s;
        }
        .m3-card:hover { border-color: rgba(118, 255, 51, 0.2); background: rgba(0,0,0,0.3); }
        .card-title { font-size: 12px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; margin-bottom: 12px; display:flex; align-items:center; gap:8px; }
        
        .slot-display { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .slot-icon { width: 48px; height: 48px; border-radius: 12px; background: rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center; color: #B0BEC5; transition: 0.3s; }
        .m3-card:hover .slot-icon { color: var(--md-sys-color-primary); background: rgba(118, 255, 51, 0.1); }
        .slot-icon svg { width: 24px; fill: currentColor; }
        .slot-text h3 { margin: 0; font-size: 16px; font-weight: 500; color: #E0F2F1; }
        .slot-text p { margin: 2px 0 0; font-size: 12px; color: #90A4AE; }

        /* M3 Inputs */
        .control-col { display: flex; flex-direction: column; gap: 12px; }
        .m3-select-container { position: relative; background: rgba(0,0,0,0.2); border-radius: 8px; border-bottom: 1px solid #546E7A; transition: 0.2s; }
        .m3-select-container:focus-within { background: rgba(118, 255, 51, 0.05); border-bottom: 2px solid var(--md-sys-color-primary); }
        .m3-select-label { position: absolute; top: 4px; left: 12px; font-size: 10px; color: var(--md-sys-color-primary); pointer-events: none; opacity: 0.8; }
        .m3-select { 
            width: 100%; background: transparent; border: none; color: #E0F2F1; padding: 20px 12px 6px; 
            font-size: 14px; outline: none; cursor: pointer; appearance: none;
        }
        .m3-select option { background: #002b40; color: #E0F2F1; padding: 10px; }

        /* Loading Spinner inside Select */
        .spinner { width: 12px; height: 12px; border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--md-sys-color-primary); border-radius: 50%; animation: spin 1s linear infinite; position: absolute; right: 12px; top: 16px; display: none; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .m3-select-container.loading .spinner { display: block; }

        /* Beta Toggle */
        .beta-toggle { display: flex; align-items: center; justify-content: space-between; padding: 12px 4px; cursor: pointer; user-select: none; }
        .beta-label { font-size: 14px; font-weight: 500; color: #B0BEC5; }
        .beta-switch { 
            width: 44px; height: 24px; background: #001926; border-radius: 100px; position: relative; transition: 0.2s; border: 2px solid #546E7A;
        }
        .beta-switch::after { 
            content: ''; position: absolute; top: 4px; left: 4px; width: 16px; height: 16px; 
            background: #546E7A; border-radius: 50%; transition: 0.2s; 
        }
        .beta-toggle.active .beta-switch { background: rgba(118, 255, 51, 0.15); border-color: var(--md-sys-color-primary); }
        .beta-toggle.active .beta-switch::after { background: var(--md-sys-color-primary); transform: translateX(20px); width: 20px; height: 20px; top: 2px; left: 0; }
        
        #group-scene { display: none; margin-top: 10px; border: 1px dashed var(--md-sys-color-outline); }
        #group-scene.visible { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity:0; transform:translateY(-10px); } to { opacity:1; transform:translateY(0); } }

        /* Footer */
        .footer { padding: 24px; background: rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 12px; border-top: 1px solid rgba(255,255,255,0.05); }
        
        .btn-filled { 
            width: 100%; padding: 14px; border: none; border-radius: 100px; 
            background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); 
            font-weight: 600; font-size: 14px; cursor: pointer; display: flex; justify-content: center; align-items: center; 
            transition: 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .btn-filled:hover { background: #9eff6b; box-shadow: 0 4px 12px rgba(118, 255, 51, 0.3); }
        .btn-filled svg { width: 20px; margin-right: 8px; fill: currentColor; }
        
        .btn-text { background: transparent; color: #B0BEC5; border: 1px solid #546E7A; padding: 10px; border-radius: 100px; cursor: pointer; font-size: 12px; transition: 0.2s; }
        .btn-text:hover { background: rgba(255,255,255,0.05); color: #E0F2F1; border-color: #78909C; }

        /* Legacy support for Normal Mode List */
        .file-list { border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; overflow: hidden; margin-top:10px; }
        .file-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); background: rgba(0,0,0,0.2); font-size: 13px; display:flex; gap:8px; align-items:center; }
        
        /* Add File Button */
        .btn-add-file { 
            position: relative; width: 100%; padding: 12px; border: 1px dashed #546E7A; border-radius: 12px;
            color: #90A4AE; text-align: center; font-size: 13px; cursor: pointer; 
            display: flex; align-items: center; justify-content: center; margin-bottom: 12px;
            transition: 0.2s; box-sizing: border-box;
        }
        .btn-add-file:hover { background: rgba(118, 255, 51, 0.05); border-color: var(--md-sys-color-primary); color: var(--md-sys-color-primary); }
        .btn-add-file input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

        /* Log Box */
        .log-box { 
            font-family: 'Consolas', monospace; font-size: 10px; color: #78909C; 
            background: #00151f; padding: 10px; border-radius: 8px; border: 1px solid #263238;
            height: 100px; overflow-y: auto; margin-bottom: 10px; display:none;
        }
        .log-line { margin-bottom: 2px; border-bottom: 1px solid #1c262b; padding-bottom: 2px; }
        .log-ok { color: #76FF33; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; } 
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #37474F; border-radius: 3px; }

        #mount-status { font-size: 12px; color: #78909C; text-align: center; display: none; align-items: center; justify-content: center; gap: 8px; margin-top: 4px; }
        #mount-status.active { color: #76FF33; }
        .status-badge { padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-weight: 700; font-size: 10px; }
    </style>
    <script type="importmap">
        { 
            "imports": { 
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
            } 
        }
    </script>
</head>
<body class="fouc-loading">

    <div id="top-bar">
        <div class="app-title" id="t-app-title">Tanki Model Showcase</div>
    </div>
    <div id="toast"><span>Ready</span></div>
    <button id="fab"><svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></button>

    <div id="drawer" class="open">
        <div class="tab-group">
            <div class="tab-btn" onclick="switchMode('assembly')" id="t-tab-assembly">Tank Assembly</div>
            <div class="tab-btn" onclick="switchMode('normal')" id="t-tab-normal">Local File</div>
        </div>

        <!-- Assembly Mode -->
        <div id="panel-assembly" class="drawer-content">
            <div style="height:20px"></div>

            <!-- Hull Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--hull)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 3L3 2H7L8 3H16V5H6V6H10L12 8H15L16 9V11L14 13H2L0 11V8L2 6V3Z" fill="currentColor"/>
                    </svg>
                    <span id="t-hull-title">Hull Configuration</span>
                </div>
                <div class="slot-display">
                    <div class="slot-icon" style="color:var(--hull)">
                        <svg width="24" height="24" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2 3L3 2H7L8 3H16V5H6V6H10L12 8H15L16 9V11L14 13H2L0 11V8L2 6V3Z" fill="currentColor"/>
                        </svg>
                    </div>
                    <div class="slot-text">
                        <h3 id="display-hull">None</h3>
                        <p id="sub-hull" class="t-hull-sub">Select a hull to equip</p>
                    </div>
                </div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-hull">
                        <span class="m3-select-label t-lbl-model">Model</span>
                        <div class="spinner"></div>
                        <select id="sel-hull-name" class="m3-select"><option>Loading...</option></select>
                    </div>
                    <div class="m3-select-container">
                        <span class="m3-select-label t-lbl-skin">Skin</span>
                        <select id="sel-hull-skin" class="m3-select"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Turret Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--turret)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M5 0H7V12H9V0H11V6L14 9V13L11 16V16H9H7H5V16L2 13V9L5 6V0Z" fill="currentColor"/>
                    </svg>
                    <span id="t-turret-title">Turret Configuration</span>
                </div>
                <div class="slot-display">
                    <div class="slot-icon" style="color:var(--turret)">
                        <svg width="24" height="24" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M5 0H7V12H9V0H11V6L14 9V13L11 16V16H9H7H5V16L2 13V9L5 6V0Z" fill="currentColor"/>
                        </svg>
                    </div>
                    <div class="slot-text">
                        <h3 id="display-turret">None</h3>
                        <p id="sub-turret" class="t-turret-sub">Select a turret to equip</p>
                    </div>
                </div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-turret">
                        <span class="m3-select-label t-lbl-model">Model</span>
                        <div class="spinner"></div>
                        <select id="sel-turret-name" class="m3-select"><option>Loading...</option></select>
                    </div>
                    <div class="m3-select-container">
                        <span class="m3-select-label t-lbl-skin">Skin</span>
                        <select id="sel-turret-skin" class="m3-select"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Beta Toggle -->
            <div class="beta-toggle" onclick="toggleScene()">
                <div class="beta-label" id="t-beta-label">Show Environment (Beta)</div>
                <div class="beta-switch" id="scene-sw"></div>
            </div>

            <!-- Hidden Scene Card -->
            <div class="m3-card" id="group-scene">
                <div class="card-title" style="color:var(--scene)" id="t-scene-title">Map / Garage</div>
                <div class="slot-display">
                    <div class="slot-text">
                        <h3 id="display-scene" class="t-scene-display">No Environment</h3>
                    </div>
                </div>
                <div id="scene-log" class="log-box"></div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-scene">
                        <span class="m3-select-label t-lbl-env">Environment</span>
                        <div class="spinner"></div>
                        <select id="sel-scene-var" class="m3-select"><option>Loading...</option></select>
                    </div>
                </div>
                <button class="btn-text t-remove-env" id="btn-clear-scene" style="width:100%;margin-top:12px;color:#ef9a9a;border-color:#ef9a9a">Remove Environment</button>
            </div>

        </div>

        <!-- Normal Mode -->
        <div id="panel-normal" class="drawer-content">
            <div style="margin: 24px 0 16px;">
                <label class="btn-add-file">
                    <svg viewBox="0 0 24 24" style="width:18px;margin-right:8px;fill:currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    <span id="t-import-btn">Import .a3d / .3ds files</span>
                    <input type="file" id="in-normal" multiple>
                </label>
            </div>
            <div class="card-title" id="t-res-title">IMPORTED RESOURCES</div>
            <div id="list-normal" class="file-list"></div>
        </div>

        <div class="footer">
            <div id="mount-status"><span class="status-badge t-mount-status">MOUNT POINT</span> <span id="mount-txt" class="t-mount-none">Not Detected</span></div>
            <button class="btn-filled" id="btn-export">
                <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                <span id="t-export">Export GLB</span>
            </button>
            <button class="btn-text t-clear" id="btn-clear">Clear All Objects</button>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TDSLoader } from 'three/addons/loaders/TDSLoader.js'; 
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'; 

    // Constants
    const ASSETS_INDEX_URL = "https://testanki1.github.io/models/assets.json";

    // --- I18n System ---
    const userLang = navigator.language.startsWith('zh') ? 'zh' : 'en';
    const RES_BASE = userLang === 'zh' ? "https://res.3dtank.com" : "https://s.eu.tankionline.com";
    
    const CNDict = {
        'default': '默认', 'firebird': '火焰炮', 'freeze': '冰风暴', 'isida': '磁力炮', 'tesla': '特斯拉', 'hammer': '滑膛炮',
        'twins': '离子炮', 'ricochet': '火龙珠', 'smoky': '轰天炮', 'striker': '火箭炮', 'vulcan': '极速炮',
        'thunder': '雷暴炮', 'scorpion': '蝎子', 'railgun': '激光炮', 'magnum': '马格南', 'gauss': '电磁炮', 'shaft': '镭射炮',
        'wasp': '黄蜂轻甲', 'hornet': '蜂王', 'hopper': '霍珀', 'paladin': '圣骑士', 'hunter': '猎人中甲',
        'crusader': '十字军', 'viking': '维京', 'dictator': '独裁者', 'ares': '阿瑞斯', 'titan': '泰坦', 'mammoth': '猛犸象',
        'brutus': '布鲁特斯', 'mechanic': '机械师', 'trickster': '魔术师', 'saboteur': '破坏者', 'booster': '助推器',
        'defender': '守卫者', 'hyperion': '亥伯龙神', 'crisis': '危机', 'supply': '道具', 'ut': '超高', 'pr': '青春',
        'lc': '遗产', 'xt': 'XT', 'dc': '恶魔', 'gt': 'GT（跑车）', 'hd': 'HD（高清）', 'rf': 'RF（复古未来）', 'se': 'SE（秘密）', 'vt': 'VT（老兵）',
        'dk': 'DK（暗黑）', 'sp': 'SP（蒸汽朋克）', 'ic': 'IC（冰）', 'old': '旧'
    };

    const Dict = {
        zh: {
            appTitle: "3D坦克模型展示",
            tabNormal: "本地文件",
            tabAssembly: "坦克组装",
            importBtn: "导入 .a3d / .3ds 文件",
            resTitle: "已导入资源",
            hullTitle: "底盘配置",
            hullSub: "选择底盘以装备",
            turretTitle: "炮塔配置",
            turretSub: "选择炮塔以装备",
            lblModel: "模型",
            lblSkin: "皮肤",
            lblEnv: "环境",
            betaLabel: "显示环境 (Beta)",
            sceneTitle: "地图 / 车库",
            sceneDisplay: "无环境",
            removeEnv: "移除环境",
            mountStatus: "挂载点",
            mountActive: "已锁定",
            mountNone: "未检测",
            export: "导出 GLB",
            clear: "清空场景",
            loading: "加载中..."
        },
        en: {
            appTitle: "Tanki Model Showcase",
            tabNormal: "Local File",
            tabAssembly: "Tank Assembly",
            importBtn: "Import .a3d / .3ds files",
            resTitle: "IMPORTED RESOURCES",
            hullTitle: "Hull Configuration",
            hullSub: "Select a hull to equip",
            turretTitle: "Turret Configuration",
            turretSub: "Select a turret to equip",
            lblModel: "Model",
            lblSkin: "Skin",
            lblEnv: "Environment",
            betaLabel: "Show Environment (Beta)",
            sceneTitle: "Map / Garage",
            sceneDisplay: "No Environment",
            removeEnv: "Remove Environment",
            mountStatus: "MOUNT POINT",
            mountActive: "Active",
            mountNone: "Not Detected",
            export: "Export GLB",
            clear: "Clear All Objects",
            loading: "Loading..."
        }
    };
    const T = Dict[userLang];

    // Apply Static Translations
    function applyI18n() {
        document.getElementById('t-app-title').innerText = T.appTitle;
        document.getElementById('t-tab-normal').innerText = T.tabNormal;
        document.getElementById('t-tab-assembly').innerText = T.tabAssembly;
        document.getElementById('t-import-btn').innerText = T.importBtn;
        document.getElementById('t-res-title').innerText = T.resTitle;
        document.getElementById('t-hull-title').innerText = T.hullTitle;
        document.getElementById('t-turret-title').innerText = T.turretTitle;
        document.getElementById('t-beta-label').innerText = T.betaLabel;
        document.getElementById('t-scene-title').innerText = T.sceneTitle;
        document.getElementById('t-export').innerText = T.export;
        
        document.querySelectorAll('.t-lbl-model').forEach(el => el.innerText = T.lblModel);
        document.querySelectorAll('.t-lbl-skin').forEach(el => el.innerText = T.lblSkin);
        document.querySelectorAll('.t-lbl-env').forEach(el => el.innerText = T.lblEnv);
        document.querySelectorAll('.t-hull-sub').forEach(el => el.innerText = T.hullSub);
        document.querySelectorAll('.t-turret-sub').forEach(el => el.innerText = T.turretSub);
        document.querySelectorAll('.t-scene-display').forEach(el => el.innerText = T.sceneDisplay);
        document.querySelectorAll('.t-remove-env').forEach(el => el.innerText = T.removeEnv);
        document.querySelectorAll('.t-mount-status').forEach(el => el.innerText = T.mountStatus);
        document.querySelectorAll('.t-mount-none').forEach(el => el.innerText = T.mountNone);
        document.querySelectorAll('.t-clear').forEach(el => el.innerText = T.clear);
    }

    // Dynamic Data Translation
    function formatName(name) {
        let text = name.replace(/_/g, ' ');
        if(userLang === 'zh') {
            return text.split(' ').map(part => {
                const lc = part.toLowerCase();
                return CNDict[lc] || part;
            }).join(' ');
        } else {
            return text.toLowerCase().split(' ').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
        }
    }

    function translateDataKey(key) {
        if (userLang === 'zh') return key;
        let k = key;
        k = k.replace(/万圣节/g, "Halloween");
        k = k.replace(/新年/g, "New Year");
        k = k.replace(/生日/g, "Birthday");
        k = k.replace(/UFO 日/g, "UFO Day");
        k = k.replace(/雪人/g, "Snowman");
        k = k.replace(/番茄炮/g, "Tomato");
        k = k.replace(/螯/g, "Claw");
        k = k.replace(/蜘蛛/g, "Spider");
        return k;
    }

    // State
    let currentMode = 'assembly'; // Default mode
    const slots = { hull: null, turret: null, scene: null };
    const pools = { hull: [], turret: [] };
    let assetsData = null; // Store fetched index
    
    // Scene Lib
    const sceneLib = { tex: new Map(), meshes: [] };
    const logBox = document.getElementById('scene-log');

    let normalMeshes = [], normalTextures = [];

    // Helpers
    const mountHelper = new THREE.Mesh(new THREE.SphereGeometry(3,8,8), new THREE.MeshBasicMaterial({color:0x76FF33}));
    mountHelper.visible = false;
    let mountPos = null;

    // Scene
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x001926);
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1e7); camera.position.set(150,150,150);
    const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true}); 
    renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio); 
    renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true;
    
    const root = new THREE.Group(); root.rotation.set(-Math.PI/2, 0, 0); scene.add(root);
    // Sub-groups for mode persistence
    const groupNormal = new THREE.Group();
    const groupAssembly = new THREE.Group();
    groupNormal.visible = false;
    groupAssembly.visible = true; // Default
    root.add(groupNormal);
    root.add(groupAssembly);
    
    root.add(mountHelper); // Helper stays in root but visibility managed

    const lg = new THREE.Group(); scene.add(lg);
    lg.add(new THREE.AmbientLight(0xffffff, 1.2));
    const sun = new THREE.DirectionalLight(0xffeebb, 2.5); sun.position.set(50,80,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); lg.add(sun);
    lg.add(new THREE.DirectionalLight(0xcceeff, 1.0));

    window.onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)};
    function animate(){requestAnimationFrame(animate);lg.quaternion.copy(camera.quaternion);controls.update();renderer.render(scene,camera)}
    animate();

    // UI Helpers
    const drawer=document.getElementById('drawer'), fab=document.getElementById('fab');
    let open=true; fab.onclick=()=>{open=!open;if(open)drawer.style.display='flex';else drawer.style.display='none'};
    function msg(t){const el=document.getElementById('toast');el.innerText=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),2000)}
    
    function log(msg) {
        const div = document.createElement('div');
        div.className = `log-line log-ok`;
        div.innerText = msg;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
    }

    // Initialize
    applyI18n();
    document.body.classList.remove('fouc-loading');

    (async function init() {
        // Set initial active state based on default currentMode='assembly'
        document.getElementById('t-tab-assembly').classList.add('active');
        document.getElementById('panel-assembly').classList.add('active');
        document.getElementById('mount-status').style.display = 'flex';
        
        try {
            msg(T.loading);
            const resp = await fetch(ASSETS_INDEX_URL);
            if(!resp.ok) throw "Fetch failed";
            assetsData = await resp.json();
            populateUI();
            
            // Auto-load if in assembly mode
            if(currentMode==='assembly') {
                if(!slots.hull && document.getElementById('sel-hull-name').value) triggerLoad('hull');
                if(!slots.turret && document.getElementById('sel-turret-name').value) triggerLoad('turret');
            }
            msg("Ready");
        } catch(e) {
            console.error(e);
            msg("Failed to load index");
        }
    })();

    // Beta Toggle Logic
    window.toggleScene = function() {
        const toggle = document.querySelector('.beta-toggle');
        const box = document.getElementById('group-scene');
        const active = toggle.classList.toggle('active');
        if(active) {
            box.classList.add('visible');
            if(!slots.scene && document.getElementById('sel-scene-var').value) triggerSceneLoad();
        } else {
            box.classList.remove('visible');
        }
    }

    function populateUI() {
        if(!assetsData) return;
        
        // Setup Hull
        const selHull = document.getElementById('sel-hull-name');
        const selHullSkin = document.getElementById('sel-hull-skin');
        selHull.innerHTML = "";
        Object.keys(assetsData.hulls || {}).forEach(k => {
            const opt = new Option(formatName(k), k);
            selHull.add(opt);
        });
        
        selHull.onchange = () => {
            updateSkinSelect('hull', selHull.value);
            if(currentMode==='assembly') triggerLoad('hull');
        };
        selHullSkin.onchange = () => { if(currentMode==='assembly') triggerLoad('hull'); };
        
        // Setup Turret
        const selTurret = document.getElementById('sel-turret-name');
        const selTurretSkin = document.getElementById('sel-turret-skin');
        selTurret.innerHTML = "";
        Object.keys(assetsData.turrets || {}).forEach(k => {
            const opt = new Option(formatName(k), k);
            selTurret.add(opt);
        });
        
        selTurret.onchange = () => {
            updateSkinSelect('turret', selTurret.value);
            if(currentMode==='assembly') triggerLoad('turret');
        };
        selTurretSkin.onchange = () => { if(currentMode==='assembly') triggerLoad('turret'); };

        // Setup Scene
        const selScene = document.getElementById('sel-scene-var');
        selScene.innerHTML = "";
        const garageData = assetsData.festivals?.garage || {};
        Object.keys(garageData).forEach(k => {
            const opt = new Option(translateDataKey(k), k);
            selScene.add(opt);
        });
        selScene.onchange = () => triggerSceneLoad();

        // Initial setup for skins
        if(selHull.options.length) updateSkinSelect('hull', selHull.value);
        if(selTurret.options.length) updateSkinSelect('turret', selTurret.value);
    }

    function updateSkinSelect(type, name) {
        const selSkin = document.getElementById(`sel-${type}-skin`);
        selSkin.innerHTML = "";
        const skins = assetsData[`${type}s`][name] || {};
        Object.keys(skins).forEach(k => {
            const opt = new Option(formatName(k), k);
            selSkin.add(opt);
        });
        let defIdx = 0;
        Array.from(selSkin.options).forEach((opt,i) => { if(opt.value==='default') defIdx=i; });
        selSkin.selectedIndex = defIdx;
    }

    // --- Loading Logic ---
    async function fetchMeta(path) {
        const url = `${RES_BASE}/${path}/meta.info`;
        const res = await fetch(url);
        return await res.json();
    }

    let loadingState = { hull: false, turret: false, scene: false };

    async function triggerLoad(type) {
        if(loadingState[type]) return; 
        
        const name = document.getElementById(`sel-${type}-name`).value;
        const skin = document.getElementById(`sel-${type}-skin`).value;
        if(!name || !skin || name==='Loading...' || skin==='-') return;

        const path = assetsData[`${type}s`][name][skin];
        if(!path) return;
        
        const box = document.getElementById(`box-${type}`);
        box.classList.add('loading');
        loadingState[type] = true;
        
        await loadRemoteAsset(path, type);
        
        box.classList.remove('loading');
        loadingState[type] = false;
        
        document.getElementById(`display-${type}`).innerText = formatName(name);
        document.getElementById(`sub-${type}`).innerText = formatName(skin);
    }

    async function triggerSceneLoad() {
        if(loadingState.scene) return;
        const variant = document.getElementById('sel-scene-var').value;
        const path = assetsData.festivals.garage[variant];
        if(!path) return;
        
        const box = document.getElementById('box-scene');
        box.classList.add('loading');
        loadingState.scene = true;
        
        await loadRemoteScene(path, variant);
        
        box.classList.remove('loading');
        loadingState.scene = false;
        
        document.getElementById(`display-scene`).innerText = `Garage: ${translateDataKey(variant)}`;
    }

    async function loadRemoteAsset(pathStr, type) {
        try {
            msg(`${T.loading} ${type}...`);
            const meta = await fetchMeta(pathStr);
            
            let modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.a3d'));
            if(!modelEntry) modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.3ds'));
            
            if(!modelEntry) throw "Model file not found";

            // Find all textures
            const imgEntries = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i) && !f.name.endsWith('.ktx'));
            
            const modelUrl = `${RES_BASE}/${pathStr}/${modelEntry.name}`;
            
            let group;
            if(modelEntry.name.endsWith('.a3d')) {
                const buf = await (await fetch(modelUrl)).arrayBuffer();
                group = parseA3D(buf, modelEntry.name);
            } else {
                const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${pathStr}/`);
                group = await loader.loadAsync(modelUrl);
                group.traverse(o => { 
                    if(o.isMesh) { 
                        o.material = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.4, side:2}); 
                        o.userData.originalName = o.name; 
                    }
                });
            }

            pools[type] = [];
            if(imgEntries.length > 0) {
                const texPromises = imgEntries.map(async entry => {
                    const texUrl = `${RES_BASE}/${pathStr}/${entry.name}`;
                    const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                    setupTex(tex); tex.name = entry.name;
                    return { name: entry.name, tex: tex };
                });
                pools[type] = await Promise.all(texPromises);
                applyTexturesFromPool(group, pools[type]);
            }

            equipAssembly(group, modelEntry.name, type);
            msg(`${type.toUpperCase()} Ready`);

        } catch(e) {
            console.error(e);
            msg(`Error loading ${type}`);
        }
    }

    function applyTexturesFromPool(group, pool) {
        if (!pool || pool.length === 0) return;
        
        const findTex = (k) => pool.find(p => p.name.toLowerCase().includes(k))?.tex;
        const texTracks = findTex('track') || findTex('chain');
        const texWheels = findTex('wheel'); 
        const texLightmap = findTex('lightmap') || findTex('map') || pool[0].tex;

        group.traverse(m => {
            if (!m.isMesh) return;
            const name = (m.userData.originalName || m.name).toLowerCase();
            let target = texLightmap;
            
            if (name.includes('track') || name.includes('chain')) target = texTracks || target;
            else if (name.includes('wheel')) target = texWheels || target;
            
            if (target) setMat(m, target);
        });
    }

    async function loadRemoteScene(path, variant) {
        if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
        sceneLib.meshes = []; sceneLib.tex.clear();
        logBox.style.display = 'block'; logBox.innerHTML='';
        
        try {
            msg(T.loading);
            const meta = await fetchMeta(path);
            
            const models = meta.filter(f => f.name.match(/\.(a3d|3ds)$/i));
            const images = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i));

            const texProm = images.map(async f => {
                const texUrl = `${RES_BASE}/${path}/${f.name}`;
                const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                tex.name = f.name; setupTex(tex);
                return { n: f.name, t: tex };
            });
            const loadedTex = await Promise.all(texProm);
            loadedTex.forEach(o => sceneLib.tex.set(o.n, o.t));

            const combinedGroup = new THREE.Group();
            
            for(let f of models) {
                const mUrl = `${RES_BASE}/${path}/${f.name}`;
                let grp;
                if(f.name.endsWith('.a3d')) {
                    const buf = await (await fetch(mUrl)).arrayBuffer();
                    grp = parseA3D(buf, f.name);
                } else {
                    const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${path}/`);
                    grp = await loader.loadAsync(mUrl);
                }
                
                grp.traverse(o => { 
                    if (o.isMesh) { 
                        if (o.parent) o.userData.parentName = o.parent.name; 
                        sceneLib.meshes.push(o); 
                    } 
                });
                combinedGroup.add(grp);
            }

            slots.scene = combinedGroup; 
            groupAssembly.add(combinedGroup);
            
            runSceneInjector();
            fitCamera();
            msg("Environment Loaded");

        } catch(e) {
            console.error(e);
            msg("Scene Load Failed");
        }
    }

    // --- Standard Functions ---

    window.switchMode = function(mode) {
        if(currentMode === mode) return;
        currentMode = mode;
        
        document.querySelectorAll('.tab-btn').forEach((el,i) => {
            // Because we swapped HTML order, 0 is assembly, 1 is normal
            const modes = ['assembly','normal'];
            el.classList.toggle('active', modes[i] === mode);
        });
        ['normal','assembly'].forEach(m => document.getElementById('panel-'+m).classList.toggle('active', m===mode));
        
        // Visibility Toggle
        groupNormal.visible = (mode === 'normal');
        groupAssembly.visible = (mode === 'assembly');
        
        if (mode === 'assembly') {
             document.getElementById('mount-status').style.display = 'flex';
             if(mountPos) mountHelper.visible = true;

             // Auto-load if empty but selected
             if(!slots.hull && document.getElementById('sel-hull-name').value) triggerLoad('hull');
             if(!slots.turret && document.getElementById('sel-turret-name').value) triggerLoad('turret');
        } else {
             document.getElementById('mount-status').style.display = 'none';
             mountHelper.visible = false;
        }
    }

    const loadingManager = new THREE.LoadingManager();

    document.getElementById('btn-clear').onclick = clearScene;

    document.getElementById('btn-export').onclick = () => {
        // Export only visible parts
        const toExport = currentMode === 'normal' ? groupNormal : groupAssembly;
        if(toExport.children.length === 0) { msg("Empty Scene"); return; }
        
        const exporter = new GLTFExporter();
        const wasVisible = mountHelper.visible; mountHelper.visible = false;
        
        // Export root with only visible to preserve X -90 rotation
        exporter.parse(root, (result) => {
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const link = document.createElement('a'); 
                link.href = URL.createObjectURL(blob); 
                link.download = 'tanki_model.glb'; 
                link.click();
                msg(T.export + " OK"); 
                mountHelper.visible = wasVisible;
            }, (err) => { 
                console.error(err); 
                msg("Export Failed"); 
                mountHelper.visible = wasVisible;
            }, { binary: true, onlyVisible: true }
        );
    };

    // Keep Local File Input for Normal Mode
    document.getElementById('in-normal').onchange = async e => {
        const arr = Array.from(e.target.files);
        const models = arr.filter(f=>f.name.match(/\.(a3d|3ds)$/i));
        const images = arr.filter(f=>f.type.startsWith('image/'));
        for(let f of models) {
            try {
                const grp = await loadModelFile(f); 
                groupNormal.add(grp);
                grp.traverse(o=>{ if(o.isMesh) normalMeshes.push(o); });
                addUI('list-normal', f.name);
            } catch(e){}
        }
        for(let f of images) {
            const url = URL.createObjectURL(f);
            new THREE.TextureLoader().load(url, t => {
                setupTex(t); t.name = f.name;
                normalTextures.push(t);
                applyNormalTexture(t);
                addUI('list-normal', f.name);
            });
        }
        fitCamera(); e.target.value='';
    };

    function runSceneInjector() {
        let count = 0; log(">>> Injecting Textures...");
        sceneLib.meshes.forEach(mesh => {
            const candidates = [];
            if (mesh.material && mesh.material.name) candidates.push(mesh.material.name);
            if (mesh.name) candidates.push(mesh.name);
            if (mesh.userData.parentName) candidates.push(mesh.userData.parentName);
            let bestTex = null;
            for (const [texName, texObj] of sceneLib.tex) {
                const cleanTexName = texName.toLowerCase().split('.')[0];
                for (const cand of candidates) {
                    const cleanCand = cand.toLowerCase();
                    if (cleanCand.includes(cleanTexName)) { bestTex = texObj; break; }
                    if (cleanTexName.includes(cleanCand) && cleanCand.length > 3) { bestTex = texObj; break; }
                }
                if (bestTex) break;
            }
            if (bestTex) {
                mesh.material = new THREE.MeshStandardMaterial({
                    map: bestTex, emissiveMap: bestTex, emissive: new THREE.Color(0x888888), 
                    color: 0xffffff, side: THREE.DoubleSide, transparent: true, alphaTest: 0.5 
                });
                mesh.material.needsUpdate = true; log(`✔ [${mesh.name}] -> ${bestTex.name}`); count++;
            }
        });
        if(count > 0) msg(`Matched ${count} materials`); else log("⚠ No matches found");
    }

    document.getElementById('btn-clear-scene').onclick = () => {
         if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
         sceneLib.tex.forEach(t => t.dispose()); sceneLib.tex.clear();
         sceneLib.meshes = [];
         logBox.innerHTML = ''; logBox.style.display = 'none';
         document.getElementById('display-scene').innerText = T.sceneDisplay;
         msg(T.removeEnv);
    };

    async function loadModelFile(file) {
        const ext = file.name.split('.').pop().toLowerCase();
        if (ext === 'a3d') return parseA3D(await file.arrayBuffer(), file.name);
        else if (ext === '3ds') {
            const loader = new TDSLoader(); loader.setResourcePath('');
            const g = await loader.loadAsync(URL.createObjectURL(file));
            g.traverse(o => { if(o.isMesh) { o.material=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.4,side:2}); o.userData.originalName=o.name; }});
            return g;
        }
    }

    function equipAssembly(grp, fname, type) {
        if(slots[type]) { groupAssembly.remove(slots[type].group); dispose(slots[type].group); }
        slots[type] = { group: grp, name: fname }; groupAssembly.add(grp);
        if(type==='hull') { scanMount(grp); snapTurret(); } else { snapTurret(); }
        // Texture is applied during load now
        fitCamera();
    }

    function scanMount(grp) {
        let found = false; grp.updateMatrixWorld(true);
        grp.traverse(o => {
            if(found) return;
            if(o.name && o.name.toLowerCase().includes("mount")) {
                const worldPos = new THREE.Vector3(); o.getWorldPosition(worldPos);
                // Convert world position to root local space (ignoring the groupAssembly wrapper since it's identity transform usually)
                // Actually, groupAssembly is child of root. 
                mountPos = root.worldToLocal(worldPos.clone()); 
                updateMount(mountPos); 
                found = true;
            }
        });
        if(!found) updateMount(null);
    }
    function snapTurret() {
        if(slots.turret) {
            if(slots.hull && mountPos) slots.turret.group.position.copy(mountPos);
            else slots.turret.group.position.set(0,0,0);
        }
    }
    
    // Normal mode texture injection
    function applyNormalTexture(tex) {
        const base = tex.name.toLowerCase().split('.')[0];
        normalMeshes.forEach(m => {
            const part = (m.userData.originalName||m.name).toLowerCase();
            let match = false;
            if(part.includes(base)) match=true;
            else if(base.includes('track') && (part.includes('track')||part.includes('chain'))) match=true;
            else if(base.includes('wheel') && part.includes('wheel')) match=true;
            else if((base.includes('lightmap')||base.includes('map')) && !part.includes('track') && !part.includes('wheel')) match=true;
            if(match) setMat(m, tex);
        });
    }

    function addUI(id, text) {
        const div = document.createElement('div'); div.className = 'file-item';
        div.innerHTML = `<svg viewBox="0 0 24 24" style="width:16px;fill:#90A4AE"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg><span style="margin-left:8px">${text}</span>`;
        document.getElementById(id).appendChild(div);
    }
    function updateMount(pos) {
        const el=document.getElementById('mount-status'), txt=document.getElementById('mount-txt');
        if(pos){
            mountHelper.position.copy(pos); 
            if(currentMode==='assembly') mountHelper.visible=true; 
            el.classList.add('active'); txt.innerText=T.mountActive;
        }
        else{
            mountHelper.visible=false; 
            el.classList.remove('active'); txt.innerText=T.mountNone;
        }
    }
    function clearScene() {
        if(currentMode === 'normal') {
            while(groupNormal.children.length > 0){
                const c = groupNormal.children[0];
                dispose(c); groupNormal.remove(c);
            }
            normalMeshes = []; normalTextures.forEach(t=>t.dispose()); normalTextures = [];
            document.getElementById('list-normal').innerHTML="";
        } else {
            if(slots.hull) { groupAssembly.remove(slots.hull.group); dispose(slots.hull.group); }
            if(slots.turret) { groupAssembly.remove(slots.turret.group); dispose(slots.turret.group); }
            if(slots.scene) { groupAssembly.remove(slots.scene); dispose(slots.scene); }
            slots.hull=null; slots.turret=null; slots.scene=null; pools.hull=[]; pools.turret=[];
            
            // Reset Displays
            document.getElementById('display-hull').innerText = "None";
            document.getElementById('sub-hull').innerText = T.hullSub;
            document.getElementById('display-turret').innerText = "None";
            document.getElementById('sub-turret').innerText = T.turretSub;
            document.getElementById('display-scene').innerText = T.sceneDisplay;
            logBox.style.display='none';
            updateMount(null);
        }
        
        sceneLib.tex.clear(); sceneLib.meshes=[];
        msg(T.clear);
    }
    function setupTex(t) { t.colorSpace=THREE.SRGBColorSpace; t.wrapS=t.wrapT=THREE.RepeatWrapping; t.anisotropy=renderer.capabilities.getMaxAnisotropy(); }
    function setMat(m, t) { m.material.map=t; m.material.emissiveMap=t; m.material.emissive=new THREE.Color(0xffffff); m.material.emissiveIntensity=0.5; m.material.needsUpdate=true; }
    function dispose(g){if(!g)return; g.traverse(o=>{if(o.isMesh){o.geometry.dispose();if(o.material)o.material.dispose()}})}
    function fitCamera(){const b=new THREE.Box3().setFromObject(root);if(b.isEmpty())return;const c=b.getCenter(new THREE.Vector3()),s=b.getSize(new THREE.Vector3()).length();controls.target.copy(c);camera.position.set(c.x+s,c.y+s*0.5,c.y+s);camera.lookAt(c);controls.update()}

    class BinR { constructor(b){this.v=new DataView(b);this.o=0;this.d=new TextDecoder()} sk(n){this.o+=n} pad(l){return(((l+3)>>2)*4)-l} u32(){const v=this.v.getUint32(this.o,1);this.o+=4;return v} i32(){const v=this.v.getInt32(this.o,1);this.o+=4;return v} u16(){const v=this.v.getUint16(this.o,1);this.o+=2;return v} f32(){const v=this.v.getFloat32(this.o,1);this.o+=4;return v} str(){const l=this.u32();const s=this.d.decode(new Uint8Array(this.v.buffer,this.v.byteOffset+this.o,l));this.o+=l+this.pad(l);return s} str0(){let b=[];while(this.o<this.v.byteLength){const c=this.v.getUint8(this.o++);if(c===0)break;b.push(c)}return this.d.decode(new Uint8Array(b))} }
    function parseA3D(buf, n) { const r = new BinR(buf); if(r.v.getUint8(0)!==65) throw "Err"; r.sk(4); const v=r.u16(); r.sk(2); if(v===3) return pV3(r, n); else if(v===2) return pV2(r, n); }
    function readC(r){r.u32();r.u32();return r.u32()}
    function pV3(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str();r.sk(12);r.str()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:r.str()};r.sk(28);m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const ic=r.u32(),x=new Uint16Array(ic);for(let k=0;k<ic;k++)x[k]=r.u16();r.sk((((ic*2+3)>>2)*4)-(ic*2));m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:r.str(),p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const o={mi:r.u32(),ti:r.u32()},cc=r.u32();for(let k=0;k<cc;k++)r.sk(4);od.push(o)} return build(md,{t:td,p:tp},od,n); }
    function pV2(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str0();r.sk(12);r.str0()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:"M"+i};m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const fc=r.u32(),x=new Uint16Array(fc*3);for(let k=0;k<fc*3;k++)x[k]=r.u16();for(let k=0;k<fc;k++)r.sk(4);r.sk(2);m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:"",p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()-1); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const s=r.str0(),mi=r.u32(),ti=r.u32(); if(td[ti])td[ti].n=s; od.push({mi,ti})} return build(md,{t:td,p:tp},od,n); }
    function build(gd,td,od,fname){const mat=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.3,metalness:0.2,side:2});const geos=gd.map(d=>{const g=new THREE.BufferGeometry();g.userData={n:d.n};d.vb.forEach(v=>{if(v.t===1)g.setAttribute('position',new THREE.BufferAttribute(v.d,3));if(v.t===3)g.setAttribute('normal',new THREE.BufferAttribute(v.d,3));if(v.t===2){for(let i=1;i<v.d.length;i+=2)v.d[i]=1.0-v.d[i];g.setAttribute('uv',new THREE.BufferAttribute(v.d,2))}});let i=[],o=0;d.sm.forEach(s=>{for(let k=0;k<s.x.length;k++)i.push(s.x[k]);g.addGroup(o,s.x.length,0);o+=s.x.length});g.setIndex(i);return g});const grp=new THREE.Group();const nds=td.t.map(t=>{const o=new THREE.Object3D();o.position.set(...t.p);o.quaternion.set(...t.q);o.scale.set(t.s[0]||1,t.s[1]||1,t.s[2]||1);o.name=t.n;return o});td.p.forEach((pid,i)=>{if(pid>=0)nds[pid].add(nds[i]);else grp.add(nds[i])});od.forEach(o=>{if(!geos[o.mi]||!nds[o.ti])return;const nm=nds[o.ti].name||geos[o.mi].userData.n;const m=new THREE.Mesh(geos[o.mi],mat.clone());if(nm.toLowerCase().match(/box|bound|col|shape/))m.visible=false;m.userData.originalName=nm;nds[o.ti].add(m)});return grp}
</script>
</body>
</html>
