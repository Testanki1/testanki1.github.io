<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanki Assembly Studio (Pro Injector)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        /* M3 Expressive Variables */
        :root {
            --md-sys-color-background: #141218;
            --md-sys-color-surface: #1D1B20;
            --md-sys-color-surface-container: #211F26;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-secondary: #CCC2DC;
            --md-sys-color-outline: #938F99;
            --md-sys-color-outline-variant: #49454F;
            
            --radius-l: 28px;
            --radius-m: 16px;
            --radius-s: 8px;
            
            --hull: #80cbc4; 
            --turret: #ffcc80; 
            --scene: #ffab91; 
        }

        body { 
            margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; 
            background: var(--md-sys-color-background); color: #E6E1E5; 
            touch-action: none; 
        }
        
        #top-bar { position: absolute; top: 0; left: 0; right: 0; padding: 24px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); pointer-events: none; z-index: 10; display:flex; flex-direction:column; gap:4px; }
        .app-title { font-weight: 500; font-size: 22px; color: #E6E1E5; letter-spacing: -0.5px; }
        .app-subtitle { font-size: 12px; color: #CAC4D0; opacity: 0.8; }

        #toast { position: absolute; top: 24px; left: 50%; transform: translateX(-50%) translateY(-20px); background: #313033; padding: 14px 24px; border-radius: 50px; opacity: 0; transition: 0.4s cubic-bezier(0.2,0,0,1); pointer-events: none; z-index: 200; box-shadow: 0 4px 8px rgba(0,0,0,0.3); font-size: 14px; color: #F4EFF4; display:flex; align-items:center; gap:8px; }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        #fab { position: absolute; bottom: 32px; right: 32px; width: 64px; height: 64px; border-radius: 20px; background: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; transition: 0.3s cubic-bezier(0.2,0,0,1); }
        #fab:hover { transform: scale(1.05); box-shadow: 0 6px 16px rgba(0,0,0,0.5); }
        #fab svg { width: 28px; fill: currentColor; }

        /* M3 Drawer / Side Sheet */
        #drawer { 
            position: absolute; top: 0; right: 0; bottom: 0; width: 360px; max-width: 95vw; 
            background: var(--md-sys-color-surface-container); 
            border-top-left-radius: var(--radius-l); border-bottom-left-radius: var(--radius-l);
            transform: translateX(110%); transition: 0.4s cubic-bezier(0.2,0,0,1); z-index: 90; 
            display: flex; flex-direction: column; box-shadow: -8px 0 24px rgba(0,0,0,0.3);
        }
        #drawer.open { transform: translateX(0); }
        
        /* M3 Tabs */
        .tab-group { display: flex; padding: 16px 16px 8px; gap: 8px; }
        .tab-btn { flex: 1; padding: 10px; text-align: center; font-size: 14px; font-weight: 500; cursor: pointer; color: #CAC4D0; border-radius: 50px; transition: 0.2s; border: 1px solid transparent; }
        .tab-btn.active { background: var(--md-sys-color-secondary); color: #332D41; font-weight: 600; }
        .tab-btn:hover:not(.active) { background: rgba(255,255,255,0.05); }
        
        .drawer-content { flex: 1; overflow-y: auto; padding: 0 20px 20px; display: none; }
        .drawer-content.active { display: block; }

        /* M3 Cards */
        .m3-card { 
            background: rgba(255,255,255,0.03); border-radius: var(--radius-m); padding: 16px; 
            margin-bottom: 16px; border: 1px solid rgba(255,255,255,0.08); transition: 0.2s;
        }
        .m3-card:hover { border-color: rgba(255,255,255,0.15); background: rgba(255,255,255,0.04); }
        .card-title { font-size: 12px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; margin-bottom: 12px; display:flex; align-items:center; gap:8px; }
        
        .slot-display { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .slot-icon { width: 48px; height: 48px; border-radius: 12px; background: rgba(208, 188, 255, 0.08); display: flex; align-items: center; justify-content: center; color: var(--md-sys-color-primary); }
        .slot-icon svg { width: 24px; fill: currentColor; }
        .slot-text h3 { margin: 0; font-size: 16px; font-weight: 500; color: #E6E1E5; }
        .slot-text p { margin: 2px 0 0; font-size: 12px; color: #CAC4D0; }

        /* M3 Inputs */
        .control-col { display: flex; flex-direction: column; gap: 12px; }
        .m3-select-container { position: relative; background: rgba(0,0,0,0.2); border-radius: 8px; border-bottom: 1px solid #938F99; transition: 0.2s; }
        .m3-select-container:focus-within { background: rgba(208, 188, 255, 0.08); border-bottom: 2px solid var(--md-sys-color-primary); }
        .m3-select-label { position: absolute; top: 4px; left: 12px; font-size: 10px; color: var(--md-sys-color-primary); pointer-events: none; }
        .m3-select { 
            width: 100%; background: transparent; border: none; color: #E6E1E5; padding: 20px 12px 6px; 
            font-size: 14px; outline: none; cursor: pointer; appearance: none;
        }
        .m3-select option { background: #2B2930; color: #E6E1E5; padding: 10px; }

        /* Loading Spinner inside Select */
        .spinner { width: 12px; height: 12px; border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--md-sys-color-primary); border-radius: 50%; animation: spin 1s linear infinite; position: absolute; right: 12px; top: 16px; display: none; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .m3-select-container.loading .spinner { display: block; }

        /* Beta Toggle */
        .beta-toggle { display: flex; align-items: center; justify-content: space-between; padding: 12px 4px; cursor: pointer; user-select: none; }
        .beta-label { font-size: 14px; font-weight: 500; color: #E6E1E5; }
        .beta-switch { 
            width: 44px; height: 24px; background: #36343B; border-radius: 100px; position: relative; transition: 0.2s; border: 2px solid #938F99;
        }
        .beta-switch::after { 
            content: ''; position: absolute; top: 4px; left: 4px; width: 16px; height: 16px; 
            background: #938F99; border-radius: 50%; transition: 0.2s; 
        }
        .beta-toggle.active .beta-switch { background: var(--md-sys-color-primary); border-color: var(--md-sys-color-primary); }
        .beta-toggle.active .beta-switch::after { background: var(--md-sys-color-on-primary); transform: translateX(20px); width: 20px; height: 20px; top: 2px; left: 0; }
        
        #group-scene { display: none; margin-top: 10px; border: 1px dashed var(--scene); }
        #group-scene.visible { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity:0; transform:translateY(-10px); } to { opacity:1; transform:translateY(0); } }

        /* Footer */
        .footer { padding: 24px; background: rgba(0,0,0,0.2); display: flex; flex-direction: column; gap: 12px; }
        
        .btn-filled { 
            width: 100%; padding: 14px; border: none; border-radius: 100px; 
            background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); 
            font-weight: 500; font-size: 14px; cursor: pointer; display: flex; justify-content: center; align-items: center; 
            transition: 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .btn-filled:hover { background: #E8DEF8; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .btn-filled svg { width: 20px; margin-right: 8px; fill: currentColor; }
        
        .btn-text { background: transparent; color: #E6E1E5; border: 1px solid #938F99; padding: 10px; border-radius: 100px; cursor: pointer; font-size: 12px; }
        .btn-text:hover { background: rgba(255,255,255,0.05); }

        /* Legacy support for Normal Mode List */
        .file-list { border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; overflow: hidden; margin-top:10px; }
        .file-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); background: rgba(0,0,0,0.2); font-size: 13px; display:flex; gap:8px; align-items:center; }
        
        /* Add File Button */
        .btn-add-file { 
            position: relative; width: 100%; padding: 12px; border: 1px dashed #938F99; border-radius: 12px;
            color: #E6E1E5; text-align: center; font-size: 13px; cursor: pointer; 
            display: flex; align-items: center; justify-content: center; margin-bottom: 12px;
            transition: 0.2s; box-sizing: border-box;
        }
        .btn-add-file:hover { background: rgba(208, 188, 255, 0.05); border-color: var(--md-sys-color-primary); }
        .btn-add-file input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

        /* Log Box */
        .log-box { 
            font-family: 'Consolas', monospace; font-size: 10px; color: #aaa; 
            background: #000; padding: 10px; border-radius: 8px; border: 1px solid #333;
            height: 100px; overflow-y: auto; margin-bottom: 10px; display:none;
        }
        .log-line { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
        .log-ok { color: #81c784; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; } 
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #49454F; border-radius: 3px; }

        #mount-status { font-size: 12px; color: #938F99; text-align: center; display: none; align-items: center; justify-content: center; gap: 8px; margin-top: 4px; }
        #mount-status.active { color: #A5D6A7; }
        .status-badge { padding: 2px 8px; background: rgba(255,255,255,0.05); border-radius: 4px; }
    </style>
    <script type="importmap">
        { 
            "imports": { 
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
            } 
        }
    </script>
</head>
<body>

    <div id="top-bar">
        <div class="app-title">Tanki Architect</div>
        <div class="app-subtitle">M3 Expressive Pro Injector</div>
    </div>
    <div id="toast"><span>Ready</span></div>
    <button id="fab"><svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></button>

    <div id="drawer" class="open">
        <div class="tab-group">
            <div class="tab-btn active" onclick="switchMode('normal')">Local File</div>
            <div class="tab-btn" onclick="switchMode('assembly')">Assembly</div>
        </div>

        <!-- Normal Mode -->
        <div id="panel-normal" class="drawer-content active">
            <div style="margin: 24px 0 16px;">
                <label class="btn-add-file">
                    <svg viewBox="0 0 24 24" style="width:18px;margin-right:8px;fill:currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    Import .a3d / .3ds files
                    <input type="file" id="in-normal" multiple>
                </label>
            </div>
            <div class="card-title">IMPORTED RESOURCES</div>
            <div id="list-normal" class="file-list"></div>
        </div>

        <!-- Assembly Mode -->
        <div id="panel-assembly" class="drawer-content">
            <div style="height:20px"></div>

            <!-- Hull Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--hull)"><svg viewBox="0 0 24 24" width="16" fill="currentColor"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg> Hull Configuration</div>
                <div class="slot-display">
                    <div class="slot-icon" style="background:rgba(128, 203, 196, 0.1);color:var(--hull)">
                        <svg viewBox="0 0 24 24"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.66 0-3 1.34-3 3 0 .35.07.69.18 1H11.82C11.93 5.69 12 5.35 12 5c0-1.66-1.34-3-3-3-1.66 0-3 1.34-3 3 0 .35.07.69.18 1H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>
                    </div>
                    <div class="slot-text">
                        <h3 id="display-hull">None</h3>
                        <p id="sub-hull">Select a hull to equip</p>
                    </div>
                </div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-hull">
                        <span class="m3-select-label">Model</span>
                        <div class="spinner"></div>
                        <select id="sel-hull-name" class="m3-select"><option>Loading...</option></select>
                    </div>
                    <div class="m3-select-container">
                        <span class="m3-select-label">Skin</span>
                        <select id="sel-hull-skin" class="m3-select"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Turret Card -->
            <div class="m3-card">
                <div class="card-title" style="color:var(--turret)"><svg viewBox="0 0 24 24" width="16" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-4-41-8-4.41-8 8-8 8 4.41 0 8 4 8 4z"/><circle cx="12" cy="12" r="3"/></svg> Turret Configuration</div>
                <div class="slot-display">
                    <div class="slot-icon" style="background:rgba(255, 204, 128, 0.1);color:var(--turret)">
                        <svg viewBox="0 0 24 24"><path d="M14.5 13.5h2v-3h-2v3zm-4-3h2v3h-2v-3zm7.5 1.5v-6h-13v6h-2v-8h17v8h-2zM5 15h14v1H5z"/></svg>
                    </div>
                    <div class="slot-text">
                        <h3 id="display-turret">None</h3>
                        <p id="sub-turret">Select a turret to equip</p>
                    </div>
                </div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-turret">
                        <span class="m3-select-label">Model</span>
                        <div class="spinner"></div>
                        <select id="sel-turret-name" class="m3-select"><option>Loading...</option></select>
                    </div>
                    <div class="m3-select-container">
                        <span class="m3-select-label">Skin</span>
                        <select id="sel-turret-skin" class="m3-select"><option>-</option></select>
                    </div>
                </div>
            </div>

            <!-- Beta Toggle -->
            <div class="beta-toggle" onclick="toggleScene()">
                <div class="beta-label">Show Environment (Beta)</div>
                <div class="beta-switch" id="scene-sw"></div>
            </div>

            <!-- Hidden Scene Card -->
            <div class="m3-card" id="group-scene">
                <div class="card-title" style="color:var(--scene)">Map / Garage</div>
                <div class="slot-display">
                    <div class="slot-text">
                        <h3 id="display-scene">No Environment</h3>
                    </div>
                </div>
                <div id="scene-log" class="log-box"></div>
                <div class="control-col">
                    <div class="m3-select-container" id="box-scene">
                        <span class="m3-select-label">Environment</span>
                        <div class="spinner"></div>
                        <select id="sel-scene-var" class="m3-select"><option>Loading...</option></select>
                    </div>
                </div>
                <button class="btn-text" id="btn-clear-scene" style="width:100%;margin-top:12px;color:#ef9a9a;border-color:#ef9a9a">Remove Environment</button>
            </div>

        </div>

        <div class="footer">
            <div id="mount-status"><span class="status-badge">MOUNT POINT</span> <span id="mount-txt">Not Detected</span></div>
            <button class="btn-filled" id="btn-export">
                <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                Export GLB
            </button>
            <button class="btn-text" id="btn-clear">Clear All Objects</button>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TDSLoader } from 'three/addons/loaders/TDSLoader.js'; 
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'; 

    // Constants
    const ASSETS_INDEX_URL = "https://testanki1.github.io/models/assets.json";
    const RES_BASE = "https://res.3dtank.com";

    // State
    let currentMode = 'normal';
    const slots = { hull: null, turret: null, scene: null };
    const pools = { hull: [], turret: [] };
    let assetsData = null; // Store fetched index
    
    // Scene Lib
    const sceneLib = { tex: new Map(), meshes: [] };
    const logBox = document.getElementById('scene-log');

    let normalMeshes = [], normalTextures = [];

    // Helpers
    const mountHelper = new THREE.Mesh(new THREE.SphereGeometry(3,8,8), new THREE.MeshBasicMaterial({color:0xff0000}));
    mountHelper.visible = false;
    let mountPos = null;

    // Scene
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x141218);
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1e7); camera.position.set(150,150,150);
    const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true}); 
    renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio); 
    renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true;
    
    const root = new THREE.Group(); root.rotation.set(-Math.PI/2, 0, 0); scene.add(root);
    root.add(mountHelper);

    const lg = new THREE.Group(); scene.add(lg);
    lg.add(new THREE.AmbientLight(0xffffff, 1.2));
    const sun = new THREE.DirectionalLight(0xffeebb, 2.5); sun.position.set(50,80,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); lg.add(sun);
    lg.add(new THREE.DirectionalLight(0xcceeff, 1.0));

    window.onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)};
    function animate(){requestAnimationFrame(animate);lg.quaternion.copy(camera.quaternion);controls.update();renderer.render(scene,camera)}
    animate();

    // UI Helpers
    const drawer=document.getElementById('drawer'), fab=document.getElementById('fab');
    let open=true; fab.onclick=()=>{open=!open;drawer.classList.toggle('open',open)};
    function msg(t){const el=document.getElementById('toast');el.innerText=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),2000)}
    
    function log(msg) {
        const div = document.createElement('div');
        div.className = `log-line log-ok`;
        div.innerText = msg;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
    }

    // Initialize
    (async function init() {
        try {
            msg("Initializing...");
            const resp = await fetch(ASSETS_INDEX_URL);
            if(!resp.ok) throw "Fetch failed";
            assetsData = await resp.json();
            populateUI();
            msg("Ready");
        } catch(e) {
            console.error(e);
            msg("Failed to load index");
        }
    })();

    // Beta Toggle Logic
    window.toggleScene = function() {
        const toggle = document.querySelector('.beta-toggle');
        const box = document.getElementById('group-scene');
        const active = toggle.classList.toggle('active');
        if(active) {
            box.classList.add('visible');
            if(!slots.scene && document.getElementById('sel-scene-var').value) triggerSceneLoad();
        } else {
            box.classList.remove('visible');
        }
    }

    function populateUI() {
        if(!assetsData) return;
        
        // Setup Hull
        const selHull = document.getElementById('sel-hull-name');
        const selHullSkin = document.getElementById('sel-hull-skin');
        selHull.innerHTML = "";
        Object.keys(assetsData.hulls || {}).forEach(k => selHull.add(new Option(k.toUpperCase(), k)));
        
        selHull.onchange = () => {
            updateSkinSelect('hull', selHull.value);
            triggerLoad('hull');
        };
        selHullSkin.onchange = () => triggerLoad('hull');
        
        // Setup Turret
        const selTurret = document.getElementById('sel-turret-name');
        const selTurretSkin = document.getElementById('sel-turret-skin');
        selTurret.innerHTML = "";
        Object.keys(assetsData.turrets || {}).forEach(k => selTurret.add(new Option(k.toUpperCase(), k)));
        
        selTurret.onchange = () => {
            updateSkinSelect('turret', selTurret.value);
            triggerLoad('turret');
        };
        selTurretSkin.onchange = () => triggerLoad('turret');

        // Setup Scene
        const selScene = document.getElementById('sel-scene-var');
        selScene.innerHTML = "";
        const garageData = assetsData.festivals?.garage || {};
        Object.keys(garageData).forEach(k => selScene.add(new Option(k, k)));
        selScene.onchange = () => triggerSceneLoad();

        if(selHull.options.length) updateSkinSelect('hull', selHull.value);
        if(selTurret.options.length) updateSkinSelect('turret', selTurret.value);
    }

    function updateSkinSelect(type, name) {
        const selSkin = document.getElementById(`sel-${type}-skin`);
        selSkin.innerHTML = "";
        const skins = assetsData[`${type}s`][name] || {};
        Object.keys(skins).forEach(k => {
            selSkin.add(new Option(k, k));
        });
        let defIdx = 0;
        Array.from(selSkin.options).forEach((opt,i) => { if(opt.value==='default') defIdx=i; });
        selSkin.selectedIndex = defIdx;
    }

    // --- Loading Logic ---
    async function fetchMeta(path) {
        const url = `${RES_BASE}/${path}/meta.info`;
        const res = await fetch(url);
        return await res.json();
    }

    let loadingState = { hull: false, turret: false, scene: false };

    async function triggerLoad(type) {
        if(loadingState[type]) return; 
        
        const name = document.getElementById(`sel-${type}-name`).value;
        const skin = document.getElementById(`sel-${type}-skin`).value;
        if(!name || !skin || name==='Loading...' || skin==='-') return;

        const path = assetsData[`${type}s`][name][skin];
        if(!path) return;
        
        const box = document.getElementById(`box-${type}`);
        box.classList.add('loading');
        loadingState[type] = true;
        
        await loadRemoteAsset(path, type);
        
        box.classList.remove('loading');
        loadingState[type] = false;
        
        document.getElementById(`display-${type}`).innerText = name.toUpperCase();
        document.getElementById(`sub-${type}`).innerText = skin;
    }

    async function triggerSceneLoad() {
        if(loadingState.scene) return;
        const variant = document.getElementById('sel-scene-var').value;
        const path = assetsData.festivals.garage[variant];
        if(!path) return;
        
        const box = document.getElementById('box-scene');
        box.classList.add('loading');
        loadingState.scene = true;
        
        await loadRemoteScene(path, variant);
        
        box.classList.remove('loading');
        loadingState.scene = false;
        
        document.getElementById(`display-scene`).innerText = `Garage: ${variant}`;
    }

    async function loadRemoteAsset(pathStr, type) {
        try {
            msg(`Loading ${type}...`);
            const meta = await fetchMeta(pathStr);
            
            let modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.a3d'));
            if(!modelEntry) modelEntry = meta.find(f => f.name.toLowerCase().endsWith('.3ds'));
            
            if(!modelEntry) throw "Model file not found";

            const imgEntries = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i) && !f.name.endsWith('.ktx'));
            
            const modelUrl = `${RES_BASE}/${pathStr}/${modelEntry.name}`;
            
            let group;
            if(modelEntry.name.endsWith('.a3d')) {
                const buf = await (await fetch(modelUrl)).arrayBuffer();
                group = parseA3D(buf, modelEntry.name);
            } else {
                const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${pathStr}/`);
                group = await loader.loadAsync(modelUrl);
                group.traverse(o => { 
                    if(o.isMesh) { 
                        o.material = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.4, side:2}); 
                        o.userData.originalName = o.name; 
                    }
                });
            }

            pools[type] = [];
            if(imgEntries.length > 0) {
                const texPromises = imgEntries.map(async entry => {
                    const texUrl = `${RES_BASE}/${pathStr}/${entry.name}`;
                    const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                    setupTex(tex); tex.name = entry.name;
                    return { name: entry.name, tex: tex };
                });
                pools[type] = await Promise.all(texPromises);
                applyTexturesFromPool(group, pools[type]);
            }

            equipAssembly(group, modelEntry.name, type);
            msg(`${type.toUpperCase()} Ready`);

        } catch(e) {
            console.error(e);
            msg(`Error loading ${type}`);
        }
    }

    function applyTexturesFromPool(group, pool) {
        if (!pool || pool.length === 0) return;
        
        const findTex = (k) => pool.find(p => p.name.toLowerCase().includes(k))?.tex;
        const texTracks = findTex('track') || findTex('chain');
        const texWheels = findTex('wheel'); 
        const texLightmap = findTex('lightmap') || findTex('map') || pool[0].tex;

        group.traverse(m => {
            if (!m.isMesh) return;
            const name = (m.userData.originalName || m.name).toLowerCase();
            let target = texLightmap;
            
            if (name.includes('track') || name.includes('chain')) target = texTracks || target;
            else if (name.includes('wheel')) target = texWheels || target;
            
            if (target) setMat(m, target);
        });
    }

    async function loadRemoteScene(path, variant) {
        if(slots.scene) { root.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
        sceneLib.meshes = []; sceneLib.tex.clear();
        logBox.style.display = 'block'; logBox.innerHTML='';
        
        try {
            msg("Parsing Scene...");
            const meta = await fetchMeta(path);
            
            const models = meta.filter(f => f.name.match(/\.(a3d|3ds)$/i));
            const images = meta.filter(f => f.name.match(/\.(webp|png|jpg|jpeg)$/i));

            const texProm = images.map(async f => {
                const texUrl = `${RES_BASE}/${path}/${f.name}`;
                const tex = await new THREE.TextureLoader().loadAsync(texUrl);
                tex.name = f.name; setupTex(tex);
                return { n: f.name, t: tex };
            });
            const loadedTex = await Promise.all(texProm);
            loadedTex.forEach(o => sceneLib.tex.set(o.n, o.t));

            const combinedGroup = new THREE.Group();
            
            for(let f of models) {
                const mUrl = `${RES_BASE}/${path}/${f.name}`;
                let grp;
                if(f.name.endsWith('.a3d')) {
                    const buf = await (await fetch(mUrl)).arrayBuffer();
                    grp = parseA3D(buf, f.name);
                } else {
                    const loader = new TDSLoader(); loader.setResourcePath(`${RES_BASE}/${path}/`);
                    grp = await loader.loadAsync(mUrl);
                }
                
                grp.traverse(o => { 
                    if (o.isMesh) { 
                        if (o.parent) o.userData.parentName = o.parent.name; 
                        sceneLib.meshes.push(o); 
                    } 
                });
                combinedGroup.add(grp);
            }

            slots.scene = combinedGroup; 
            root.add(combinedGroup);
            
            runSceneInjector();
            fitCamera();
            msg("Environment Loaded");

        } catch(e) {
            console.error(e);
            msg("Scene Load Failed");
        }
    }

    // --- Standard Functions ---

    window.switchMode = function(mode) {
        currentMode = mode;
        document.querySelectorAll('.tab-btn').forEach((el,i) => {
            el.classList.toggle('active', ['normal','assembly'][i] === mode);
        });
        ['normal','assembly'].forEach(m => document.getElementById('panel-'+m).classList.toggle('active', m===mode));
        clearScene();
        document.getElementById('mount-status').style.display = mode==='assembly' ? 'flex' : 'none';
    }

    const loadingManager = new THREE.LoadingManager();

    document.getElementById('btn-clear').onclick = clearScene;

    document.getElementById('btn-export').onclick = () => {
        if(root.children.length <= 1) { msg("场景为空"); return; }
        const exporter = new GLTFExporter();
        const wasVisible = mountHelper.visible; mountHelper.visible = false;
        const oldRot = root.rotation.x;
        root.rotation.x = 0; 
        root.updateMatrixWorld();
        exporter.parse(root, (result) => {
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const link = document.createElement('a'); 
                link.href = URL.createObjectURL(blob); 
                link.download = 'tanki_project.glb'; 
                link.click();
                msg("导出成功"); 
                root.rotation.x = oldRot; mountHelper.visible = wasVisible;
            }, (err) => { console.error(err); msg("导出出错"); root.rotation.x = oldRot; mountHelper.visible = wasVisible; }, { binary: true }
        );
    };

    // Keep Local File Input for Normal Mode
    document.getElementById('in-normal').onchange = async e => {
        const arr = Array.from(e.target.files);
        const models = arr.filter(f=>f.name.match(/\.(a3d|3ds)$/i));
        const images = arr.filter(f=>f.type.startsWith('image/'));
        for(let f of models) {
            try {
                const grp = await loadModelFile(f); 
                root.add(grp);
                grp.traverse(o=>{ if(o.isMesh) normalMeshes.push(o); });
                addUI('list-normal', f.name);
            } catch(e){}
        }
        for(let f of images) {
            const url = URL.createObjectURL(f);
            new THREE.TextureLoader().load(url, t => {
                setupTex(t); t.name = f.name;
                normalTextures.push(t);
                applyNormalTexture(t);
                addUI('list-normal', f.name);
            });
        }
        fitCamera(); e.target.value='';
    };

    function runSceneInjector() {
        let count = 0; log(">>> 开始纹理注入...");
        sceneLib.meshes.forEach(mesh => {
            const candidates = [];
            if (mesh.material && mesh.material.name) candidates.push(mesh.material.name);
            if (mesh.name) candidates.push(mesh.name);
            if (mesh.userData.parentName) candidates.push(mesh.userData.parentName);
            let bestTex = null;
            for (const [texName, texObj] of sceneLib.tex) {
                const cleanTexName = texName.toLowerCase().split('.')[0];
                for (const cand of candidates) {
                    const cleanCand = cand.toLowerCase();
                    if (cleanCand.includes(cleanTexName)) { bestTex = texObj; break; }
                    if (cleanTexName.includes(cleanCand) && cleanCand.length > 3) { bestTex = texObj; break; }
                }
                if (bestTex) break;
            }
            if (bestTex) {
                mesh.material = new THREE.MeshStandardMaterial({
                    map: bestTex, emissiveMap: bestTex, emissive: new THREE.Color(0x888888), 
                    color: 0xffffff, side: THREE.DoubleSide, transparent: true, alphaTest: 0.5 
                });
                mesh.material.needsUpdate = true; log(`✔ [${mesh.name}] -> ${bestTex.name}`); count++;
            }
        });
        if(count > 0) msg(`匹配了 ${count} 个材质`); else log("⚠ 未找到匹配");
    }

    document.getElementById('btn-clear-scene').onclick = () => {
         if(slots.scene) { root.remove(slots.scene); dispose(slots.scene); slots.scene=null; }
         sceneLib.tex.forEach(t => t.dispose()); sceneLib.tex.clear();
         sceneLib.meshes = [];
         logBox.innerHTML = ''; logBox.style.display = 'none';
         document.getElementById('display-scene').innerText = "No Environment";
         msg("Environment Removed");
    };

    async function loadModelFile(file) {
        const ext = file.name.split('.').pop().toLowerCase();
        if (ext === 'a3d') return parseA3D(await file.arrayBuffer(), file.name);
        else if (ext === '3ds') {
            const loader = new TDSLoader(); loader.setResourcePath('');
            const g = await loader.loadAsync(URL.createObjectURL(file));
            g.traverse(o => { if(o.isMesh) { o.material=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.4,side:2}); o.userData.originalName=o.name; }});
            return g;
        }
    }

    function equipAssembly(grp, fname, type) {
        if(slots[type]) { root.remove(slots[type].group); dispose(slots[type].group); }
        slots[type] = { group: grp, name: fname }; root.add(grp);
        if(type==='hull') { scanMount(grp); snapTurret(); } else { snapTurret(); }
        // Texture is applied during load now
        fitCamera();
    }

    function scanMount(grp) {
        let found = false; grp.updateMatrixWorld(true);
        grp.traverse(o => {
            if(found) return;
            if(o.name && o.name.toLowerCase().includes("mount")) {
                const worldPos = new THREE.Vector3(); o.getWorldPosition(worldPos);
                mountPos = root.worldToLocal(worldPos.clone()); updateMount(mountPos); found = true;
            }
        });
        if(!found) updateMount(null);
    }
    function snapTurret() {
        if(slots.turret) {
            if(slots.hull && mountPos) slots.turret.group.position.copy(mountPos);
            else slots.turret.group.position.set(0,0,0);
        }
    }
    
    // Normal mode texture injection
    function applyNormalTexture(tex) {
        const base = tex.name.toLowerCase().split('.')[0];
        normalMeshes.forEach(m => {
            const part = (m.userData.originalName||m.name).toLowerCase();
            let match = false;
            if(part.includes(base)) match=true;
            else if(base.includes('track') && (part.includes('track')||part.includes('chain'))) match=true;
            else if(base.includes('wheel') && part.includes('wheel')) match=true;
            else if((base.includes('lightmap')||base.includes('map')) && !part.includes('track') && !part.includes('wheel')) match=true;
            if(match) setMat(m, tex);
        });
    }

    function addUI(id, text) {
        const div = document.createElement('div'); div.className = 'tex-item';
        div.innerHTML = `<svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>${text}`;
        document.getElementById(id).appendChild(div);
    }
    function updateMount(pos) {
        const el=document.getElementById('mount-status'), txt=document.getElementById('mount-txt');
        if(pos){mountHelper.position.copy(pos); mountHelper.visible=true; el.classList.add('active'); txt.innerText="Active";}
        else{mountHelper.visible=false; el.classList.remove('active'); txt.innerText="Not Detected";}
    }
    function clearScene() {
        if(slots.hull) dispose(slots.hull.group); if(slots.turret) dispose(slots.turret.group); if(slots.scene) dispose(slots.scene);
        slots.hull=null; slots.turret=null; slots.scene=null; pools.hull=[]; pools.turret=[];
        normalMeshes.forEach(m=>{m.geometry.dispose();m.material.dispose();root.remove(m)});
        for(let i=root.children.length-1; i>=0; i--) if(root.children[i]!==mountHelper) root.remove(root.children[i]);
        normalMeshes=[]; normalTextures.forEach(t=>t.dispose()); normalTextures=[];
        sceneLib.tex.clear(); sceneLib.meshes=[];
        
        document.getElementById('list-normal').innerHTML="";
        
        // Reset Displays
        document.getElementById('display-hull').innerText = "None";
        document.getElementById('sub-hull').innerText = "Select a hull to equip";
        document.getElementById('display-turret').innerText = "None";
        document.getElementById('sub-turret').innerText = "Select a turret to equip";
        document.getElementById('display-scene').innerText = "No Environment";
        
        logBox.style.display='none';
        updateMount(null); msg("Scene Cleared");
    }
    function setupTex(t) { t.colorSpace=THREE.SRGBColorSpace; t.wrapS=t.wrapT=THREE.RepeatWrapping; t.anisotropy=renderer.capabilities.getMaxAnisotropy(); }
    function setMat(m, t) { m.material.map=t; m.material.emissiveMap=t; m.material.emissive=new THREE.Color(0xffffff); m.material.emissiveIntensity=0.5; m.material.needsUpdate=true; }
    function dispose(g){if(!g)return; g.traverse(o=>{if(o.isMesh){o.geometry.dispose();if(o.material)o.material.dispose()}})}
    function fitCamera(){const b=new THREE.Box3().setFromObject(root);if(b.isEmpty())return;const c=b.getCenter(new THREE.Vector3()),s=b.getSize(new THREE.Vector3()).length();controls.target.copy(c);camera.position.set(c.x+s,c.y+s*0.5,c.z+s);camera.lookAt(c);controls.update()}

    class BinR { constructor(b){this.v=new DataView(b);this.o=0;this.d=new TextDecoder()} sk(n){this.o+=n} pad(l){return(((l+3)>>2)*4)-l} u32(){const v=this.v.getUint32(this.o,1);this.o+=4;return v} i32(){const v=this.v.getInt32(this.o,1);this.o+=4;return v} u16(){const v=this.v.getUint16(this.o,1);this.o+=2;return v} f32(){const v=this.v.getFloat32(this.o,1);this.o+=4;return v} str(){const l=this.u32();const s=this.d.decode(new Uint8Array(this.v.buffer,this.v.byteOffset+this.o,l));this.o+=l+this.pad(l);return s} str0(){let b=[];while(this.o<this.v.byteLength){const c=this.v.getUint8(this.o++);if(c===0)break;b.push(c)}return this.d.decode(new Uint8Array(b))} }
    function parseA3D(buf, n) { const r = new BinR(buf); if(r.v.getUint8(0)!==65) throw "Err"; r.sk(4); const v=r.u16(); r.sk(2); if(v===3) return pV3(r, n); else if(v===2) return pV2(r, n); }
    function readC(r){r.u32();r.u32();return r.u32()}
    function pV3(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str();r.sk(12);r.str()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:r.str()};r.sk(28);m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const ic=r.u32(),x=new Uint16Array(ic);for(let k=0;k<ic;k++)x[k]=r.u16();r.sk((((ic*2+3)>>2)*4)-(ic*2));m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:r.str(),p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const o={mi:r.u32(),ti:r.u32()},cc=r.u32();for(let k=0;k<cc;k++)r.sk(4);od.push(o)} return build(md,{t:td,p:tp},od,n); }
    function pV2(r,n){ r.u32();r.u32(); const mc=readC(r); for(let i=0;i<mc;i++){r.str0();r.sk(12);r.str0()} const mdc=readC(r); let md=[]; for(let i=0;i<mdc;i++){let m={n:"M"+i};m.vc=r.u32();const c=r.u32();m.vb=[];for(let j=0;j<c;j++){const k=r.u32(),s=(k===5?4:(k<7&&k!==2?3:2)),d=new Float32Array(m.vc*s);for(let l=0;l<m.vc*s;l++)d[l]=r.f32();m.vb.push({t:k,d})}const sc=r.u32();m.sm=[];for(let j=0;j<sc;j++){const fc=r.u32(),x=new Uint16Array(fc*3);for(let k=0;k<fc*3;k++)x[k]=r.u16();for(let k=0;k<fc;k++)r.sk(4);r.sk(2);m.sm.push({x})}md.push(m)} const tc=readC(r); let td=[],tp=[]; for(let i=0;i<tc;i++){td.push({n:"",p:[r.f32(),r.f32(),r.f32()],q:[r.f32(),r.f32(),r.f32(),r.f32()],s:[r.f32(),r.f32(),r.f32()]})} for(let i=0;i<tc;i++)tp.push(r.i32()-1); const oc=readC(r); let od=[]; for(let i=0;i<oc;i++){const s=r.str0(),mi=r.u32(),ti=r.u32(); if(td[ti])td[ti].n=s; od.push({mi,ti})} return build(md,{t:td,p:tp},od,n); }
    function build(gd,td,od,fname){const mat=new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.3,metalness:0.2,side:2});const geos=gd.map(d=>{const g=new THREE.BufferGeometry();g.userData={n:d.n};d.vb.forEach(v=>{if(v.t===1)g.setAttribute('position',new THREE.BufferAttribute(v.d,3));if(v.t===3)g.setAttribute('normal',new THREE.BufferAttribute(v.d,3));if(v.t===2){for(let i=1;i<v.d.length;i+=2)v.d[i]=1.0-v.d[i];g.setAttribute('uv',new THREE.BufferAttribute(v.d,2))}});let i=[],o=0;d.sm.forEach(s=>{for(let k=0;k<s.x.length;k++)i.push(s.x[k]);g.addGroup(o,s.x.length,0);o+=s.x.length});g.setIndex(i);return g});const grp=new THREE.Group();const nds=td.t.map(t=>{const o=new THREE.Object3D();o.position.set(...t.p);o.quaternion.set(...t.q);o.scale.set(t.s[0]||1,t.s[1]||1,t.s[2]||1);o.name=t.n;return o});td.p.forEach((pid,i)=>{if(pid>=0)nds[pid].add(nds[i]);else grp.add(nds[i])});od.forEach(o=>{if(!geos[o.mi]||!nds[o.ti])return;const nm=nds[o.ti].name||geos[o.mi].userData.n;const m=new THREE.Mesh(geos[o.mi],mat.clone());if(nm.toLowerCase().match(/box|bound|col|shape/))m.visible=false;m.userData.originalName=nm;nds[o.ti].add(m)});return grp}
</script>
</body>
</html>
