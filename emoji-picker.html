<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3 Emoji Picker</title>
    <style>
        :root {
            /* M3 Core Colors - Light/Blue Theme */
            --md-sys-color-primary: #0061a4;
            --md-sys-color-on-primary: #ffffff;
            --md-sys-color-primary-container: #d1e4ff;
            --md-sys-color-on-primary-container: #001d36;
            
            --md-sys-color-secondary: #535f70;
            --md-sys-color-secondary-container: #d7e3f7;
            --md-sys-color-on-secondary-container: #101c2b;

            --md-sys-color-surface: #fdfcff;
            --md-sys-color-surface-container: #f0f4f9; /* Slightly darker than surface */
            --md-sys-color-on-surface: #1a1c1e;
            --md-sys-color-on-surface-variant: #43474e;
            
            --md-sys-color-outline: #73777f;
            --md-sys-color-outline-variant: #c3c7cf;

            --md-ref-typeface-brand: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            
            /* Elevation & Shape */
            --md-sys-shape-corner-small: 8px;
            --md-sys-shape-corner-medium: 12px;
            --md-sys-shape-corner-large: 16px;
            --md-sys-shape-corner-full: 9999px;
            
            --md-sys-elevation-1: 0px 1px 3px 1px rgba(0, 0, 0, 0.15), 0px 1px 2px 0px rgba(0, 0, 0, 0.3);
            --md-sys-elevation-3: 0px 4px 8px 3px rgba(0, 0, 0, 0.15), 0px 1px 3px 0px rgba(0, 0, 0, 0.3);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --md-sys-color-primary: #9ecaff;
                --md-sys-color-on-primary: #003258;
                --md-sys-color-primary-container: #00497d;
                --md-sys-color-on-primary-container: #d1e4ff;
                
                --md-sys-color-surface: #1a1c1e;
                --md-sys-color-surface-container: #202429;
                --md-sys-color-on-surface: #e2e2e6;
                --md-sys-color-on-surface-variant: #c3c7cf;
                
                --md-sys-color-outline: #8d9199;
                --md-sys-color-outline-variant: #43474e;
                
                --md-sys-color-secondary-container: #3b4858;
                --md-sys-color-on-secondary-container: #d7e3f7;
            }
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-family: var(--md-ref-typeface-brand);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Loading State */
        #loading {
            position: fixed; inset: 0; z-index: 50;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: var(--md-sys-color-surface);
            gap: 16px;
        }
        .spinner {
            width: 48px; height: 48px;
            border: 5px solid var(--md-sys-color-primary-container);
            border-bottom-color: var(--md-sys-color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- Header & Tabs --- */
        header {
            flex-shrink: 0;
            background: var(--md-sys-color-surface);
            padding: 8px 0;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .status-tabs {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 0 16px 8px 16px;
            scrollbar-width: none;
        }
        .status-tabs::-webkit-scrollbar { display: none; }

        .tab-chip {
            flex: 0 0 auto;
            height: 32px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--md-sys-shape-corner-full);
            border: 1px solid var(--md-sys-color-outline);
            color: var(--md-sys-color-on-surface-variant);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            text-transform: capitalize;
        }
        .tab-chip.active {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: transparent;
        }
        .tab-chip:hover:not(.active) {
            background-color: rgba(0,0,0,0.05);
        }

        /* --- Main Content --- */
        #main-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 16px 80px 16px; /* Bottom padding for nav and safe area */
            scroll-behavior: smooth;
        }

        .group-header {
            font-size: 22px;
            font-weight: 400;
            color: var(--md-sys-color-on-surface);
            padding: 24px 0 16px 0;
            position: sticky;
            top: 0;
            background: rgba(253, 252, 255, 0.95); /* Semi-transparent background matching surface */
            backdrop-filter: blur(5px);
            z-index: 10;
        }
        @media (prefers-color-scheme: dark) {
            .group-header { background: rgba(26, 28, 30, 0.95); }
        }

        .subgroup-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--md-sys-color-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 16px 0 8px 0;
            display: flex;
            align-items: center;
        }
        .subgroup-title::after {
            content: ''; flex: 1; height: 1px;
            background: var(--md-sys-color-outline-variant);
            margin-left: 12px; opacity: 0.5;
        }

        /* --- Emoji Grid --- */
        .emoji-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        /* The container for a set of related emojis (base + variants) */
        .variant-set {
            display: inline-flex;
            flex-wrap: wrap;
            align-items: center;
            background-color: var(--md-sys-color-surface-container);
            border-radius: var(--md-sys-shape-corner-large);
            padding: 4px;
            gap: 2px;
        }

        .emoji-item {
            width: 48px;
            height: 48px;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: var(--md-sys-shape-corner-medium);
            transition: transform 0.1s, background-color 0.2s;
            user-select: none;
            position: relative;
        }
        .emoji-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        @media (prefers-color-scheme: dark) {
            .emoji-item:hover { background-color: rgba(255,255,255,0.1); }
        }
        .emoji-item:active {
            transform: scale(0.92);
        }

        /* Dashed separator for base variants */
        .emoji-item.base-last {
            margin-right: 6px;
        }
        .emoji-item.base-last::after {
            content: "";
            position: absolute;
            right: -5px;
            top: 10px;
            bottom: 10px;
            width: 1px;
            border-right: 1px dashed var(--md-sys-color-outline);
            opacity: 0.5;
            pointer-events: none;
        }

        /* --- Bottom Navigation --- */
        .bottom-nav {
            flex-shrink: 0;
            height: 80px;
            background-color: var(--md-sys-color-surface-container);
            border-top: 1px solid var(--md-sys-color-outline-variant);
            display: flex;
            align-items: center;
            overflow-x: auto;
            padding: 0 16px;
            gap: 8px;
            scrollbar-width: none;
        }
        .bottom-nav::-webkit-scrollbar { display: none; }

        .nav-item {
            padding: 8px 16px;
            height: 48px;
            border-radius: var(--md-sys-shape-corner-full);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface-variant);
            white-space: nowrap;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .nav-item.active {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }
        .nav-item:hover:not(.active) {
            background-color: rgba(0,0,0,0.05);
        }

        /* --- Tooltip / Toast --- */
        #tooltip {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            background-color: var(--md-sys-color-on-surface);
            color: var(--md-sys-color-surface);
            padding: 12px 24px;
            border-radius: var(--md-sys-shape-corner-medium);
            box-shadow: var(--md-sys-elevation-3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            text-align: center;
            max-width: 90vw;
        }
        #tooltip.show {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }
        #tooltip .t-main {
            display: block;
            font-size: 16px;
            font-weight: 500;
        }
        #tooltip .t-sub {
            display: block;
            font-size: 12px;
            opacity: 0.8;
            margin-top: 2px;
        }
        #tooltip .t-action {
            display: block;
            font-size: 11px;
            color: #88cfff; /* Accent within tooltip */
            margin-top: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
        }

    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Emoji Data...</div>
    </div>

    <header>
        <div class="status-tabs" id="status-tabs">
            <!-- Populated via JS -->
        </div>
    </header>

    <div id="main-content">
        <!-- Emoji Groups Populated via JS -->
    </div>

    <nav class="bottom-nav" id="bottom-nav">
        <!-- Group Nav Populated via JS -->
    </nav>

    <div id="tooltip"></div>

    <script>
        // --- Constants & State ---
        // Primary URL (Official). If this fails due to CORS, we fallback.
        const OFFICIAL_URL = 'https://www.unicode.org/Public/emoji/latest/emoji-test.txt';
        // GitHub Mirror that usually allows CORS (Fallback)
        const FALLBACK_URL = 'https://raw.githubusercontent.com/unicode-org/cldr/main/tools/cldr-code/src/main/resources/org/unicode/cldr/util/data/emoji/emoji-test.txt';
        
        const CACHE_KEY = 'm3_emoji_data_v1';
        
        let emojiData = {}; // Structure: { [Status]: { [Group]: { [Subgroup]: { [BaseName]: [Array of variants] } } } }
        let availableStatuses = new Set();
        let currentStatus = '';
        let currentGroups = [];
        let isAutoScrolling = false;
        let tooltipTimer = null;
        let tooltipEl = document.getElementById('tooltip');
        let mainContent = document.getElementById('main-content');

        // --- Init ---
        async function init() {
            try {
                // Check Cache
                const cached = localStorage.getItem(CACHE_KEY);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    emojiData = parsed.data;
                    // Reconstruct Set from keys
                    availableStatuses = new Set(Object.keys(emojiData));
                } else {
                    await fetchData();
                }
                
                // Determine default status (prefer fully-qualified)
                const statuses = Array.from(availableStatuses).sort();
                currentStatus = statuses.includes('fully-qualified') ? 'fully-qualified' : statuses[0];
                
                renderUI();
                document.getElementById('loading').style.display = 'none';
            } catch (e) {
                document.getElementById('loading').innerHTML = `<div style="color:red; text-align:center; padding:20px;">Error: ${e.message}<br><br><small>If you are opening this as a local HTML file, browser security might block the request.</small></div>`;
            }
        }

        // --- Data Fetching & Parsing ---
        async function fetchData() {
            let text = '';
            try {
                // Try official first
                const res = await fetch(OFFICIAL_URL);
                if (!res.ok) throw new Error('Network response not ok');
                text = await res.text();
            } catch (err) {
                console.warn('Official fetch failed (likely CORS), trying fallback...');
                // Try fallback
                const res = await fetch(FALLBACK_URL);
                if (!res.ok) throw new Error('Fallback fetch failed');
                text = await res.text();
            }
            
            parseData(text);
            localStorage.setItem(CACHE_KEY, JSON.stringify({ data: emojiData, timestamp: Date.now() }));
        }

        function parseData(text) {
            const lines = text.split('\n');
            let curGroup = 'Unknown';
            let curSubGroup = 'Unknown';

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line.startsWith('# group:')) {
                    curGroup = line.split(': ')[1].trim();
                    return;
                }
                if (line.startsWith('# subgroup:')) {
                    curSubGroup = line.split(': ')[1].trim();
                    return;
                }
                if (line.startsWith('#')) return; // Other comments

                // Line format: CodePoints ; Status # Emoji Name
                // Example: 1F600 ; fully-qualified # ðŸ˜€ grinning face
                if (line.includes(';')) {
                    const parts = line.split(';');
                    const codePoints = parts[0].trim();
                    const remainder = parts[1].split('#');
                    const status = remainder[0].trim();
                    const comment = remainder[1].trim();
                    
                    // Comment format: [EmojiChar] [Name] (may contain colons)
                    // We need to separate the char from the name.
                    // Usually the first space separates char and name.
                    const firstSpaceIndex = comment.indexOf(' ');
                    const char = comment.substring(0, firstSpaceIndex);
                    const fullName = comment.substring(firstSpaceIndex + 1).trim();

                    // Logic for Base Name vs Variant
                    // E.g. "person: red hair" -> Base: "person", Qual: "red hair"
                    const nameParts = fullName.split(':');
                    const baseName = nameParts[0].trim();
                    const qualifier = nameParts.length > 1 ? nameParts.slice(1).join(':').trim() : "";

                    // Build Structure
                    if (!availableStatuses.has(status)) availableStatuses.add(status);
                    
                    if (!emojiData[status]) emojiData[status] = {};
                    if (!emojiData[status][curGroup]) emojiData[status][curGroup] = {};
                    if (!emojiData[status][curGroup][curSubGroup]) emojiData[status][curGroup][curSubGroup] = {};
                    if (!emojiData[status][curGroup][curSubGroup][baseName]) {
                        emojiData[status][curGroup][curSubGroup][baseName] = [];
                    }

                    emojiData[status][curGroup][curSubGroup][baseName].push({
                        char: char,
                        base: baseName,
                        qual: qualifier,
                        full: fullName
                    });
                }
            });
        }

        // --- Rendering ---
        function renderUI() {
            renderTabs();
            renderMainContent();
            renderNav();
        }

        function renderTabs() {
            const container = document.getElementById('status-tabs');
            container.innerHTML = '';
            
            const sortedStatuses = Array.from(availableStatuses).sort(); // simple sort
            
            sortedStatuses.forEach(status => {
                const chip = document.createElement('div');
                chip.className = `tab-chip ${status === currentStatus ? 'active' : ''}`;
                chip.innerText = status.replace(/-/g, ' ');
                chip.onclick = () => {
                    if (currentStatus === status) return;
                    currentStatus = status;
                    renderUI();
                };
                container.appendChild(chip);
            });
        }

        function renderMainContent() {
            mainContent.innerHTML = '';
            mainContent.scrollTop = 0;
            
            const groupData = emojiData[currentStatus];
            if (!groupData) {
                mainContent.innerHTML = '<div style="padding:20px; text-align:center;">No emojis found for this status.</div>';
                return;
            }

            currentGroups = Object.keys(groupData);

            currentGroups.forEach(groupName => {
                const groupEl = document.createElement('div');
                groupEl.id = `g-${groupName.replace(/\s+/g, '-')}`;
                
                // Group Header
                const header = document.createElement('div');
                header.className = 'group-header';
                header.innerText = groupName;
                groupEl.appendChild(header);

                // Subgroups
                const subgroups = groupData[groupName];
                Object.keys(subgroups).forEach(subGroupName => {
                    const sgTitle = document.createElement('div');
                    sgTitle.className = 'subgroup-title';
                    sgTitle.innerText = subGroupName;
                    groupEl.appendChild(sgTitle);

                    const sgContainer = document.createElement('div');
                    sgContainer.className = 'emoji-row';
                    
                    const baseNames = subgroups[subGroupName];
                    Object.keys(baseNames).forEach(baseName => {
                        const items = baseNames[baseName];
                        
                        // If multiple variants (base + skin tones/hair), group them
                        // Check if we have items with empty qualifier (true base) and items with qualifiers
                        const baseItems = items.filter(i => i.qual === "");
                        const variantItems = items.filter(i => i.qual !== "");
                        
                        if (items.length > 1 && baseItems.length > 0 && variantItems.length > 0) {
                            // Render as a set
                            const setEl = document.createElement('div');
                            setEl.className = 'variant-set';
                            
                            baseItems.forEach((item, idx) => {
                                const isLast = idx === baseItems.length - 1;
                                setEl.appendChild(createEmojiItem(item, isLast));
                            });
                            variantItems.forEach(item => {
                                setEl.appendChild(createEmojiItem(item, false));
                            });
                            
                            sgContainer.appendChild(setEl);
                        } else {
                            // Render individually (or all in one plain row if just multiple unlinked variants)
                            items.forEach(item => {
                                sgContainer.appendChild(createEmojiItem(item, false));
                            });
                        }
                    });
                    
                    groupEl.appendChild(sgContainer);
                });

                mainContent.appendChild(groupEl);
            });
            
            // Re-attach scroll listener
            mainContent.onscroll = handleScroll;
        }

        function createEmojiItem(item, isBaseLast) {
            const el = document.createElement('div');
            el.className = `emoji-item ${isBaseLast ? 'base-last' : ''}`;
            el.innerText = item.char;
            
            // Click to copy
            el.onclick = () => {
                navigator.clipboard.writeText(item.char).then(() => {
                    showToast(item.full, "Copied to clipboard!");
                });
            };

            // Long Press / Hover
            el.onpointerdown = () => showToast(item.full, null, false);
            el.onmouseenter = () => showToast(item.full, null, false);
            el.onmouseleave = hideToast;

            return el;
        }

        function renderNav() {
            const nav = document.getElementById('bottom-nav');
            nav.innerHTML = '';
            
            currentGroups.forEach((groupName, idx) => {
                const navItem = document.createElement('div');
                navItem.className = `nav-item ${idx === 0 ? 'active' : ''}`;
                navItem.innerText = groupName;
                navItem.dataset.group = groupName;
                navItem.onclick = () => {
                    isAutoScrolling = true;
                    
                    // Update Active Visual
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    navItem.classList.add('active');
                    navItem.scrollIntoView({ behavior: 'smooth', inline: 'center' });

                    // Scroll Main Content
                    const targetId = `g-${groupName.replace(/\s+/g, '-')}`;
                    const target = document.getElementById(targetId);
                    if (target) {
                        // Offset for sticky header
                        const offset = target.offsetTop; 
                        mainContent.scrollTo({ top: offset, behavior: 'smooth' });
                    }

                    setTimeout(() => { isAutoScrolling = false; }, 800);
                };
                nav.appendChild(navItem);
            });
        }

        // --- Event Handlers ---
        
        function handleScroll() {
            if (isAutoScrolling) return;

            // Detect which group is currently in view
            // Simple logic: find first group header that is above the middle of screen or at top
            const offset = 100; // Trigger point
            let currentId = null;

            for (let g of currentGroups) {
                const id = `g-${g.replace(/\s+/g, '-')}`;
                const el = document.getElementById(id);
                if (el) {
                    const rect = el.getBoundingClientRect();
                    // If element top is 'above' a certain threshold relative to viewport
                    if (rect.top <= 150) {
                        currentId = g;
                    }
                }
            }
            
            if (currentId) {
                document.querySelectorAll('.nav-item').forEach(i => {
                    if (i.dataset.group === currentId) {
                        if (!i.classList.contains('active')) {
                            i.classList.add('active');
                            i.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                        }
                    } else {
                        i.classList.remove('active');
                    }
                });
            }
        }

        function showToast(mainText, actionText, autoHide = true) {
            clearTimeout(tooltipTimer);
            
            let html = `<span class="t-main">${mainText}</span>`;
            if (actionText) {
                html += `<span class="t-action">${actionText}</span>`;
            }
            
            tooltipEl.innerHTML = html;
            tooltipEl.classList.add('show');

            if (autoHide) {
                tooltipTimer = setTimeout(hideToast, 2000);
            }
        }

        function hideToast() {
            tooltipEl.classList.remove('show');
        }

        // Run
        init();

    </script>
</body>
</html>
